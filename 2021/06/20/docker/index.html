<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  
  <title itemprop="name">docker | LKarrie</title>
  
    <link rel="shortcut icon" href="/images/favicon.ico">
  
  <meta http-equiv="x-dns-prefetch-control" content="on">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+SerifMerriweather|Merriweather+Sans|Source+Code+Pro|Ubuntu:400,700|Noto+Serif+SC" media="all">
  <link rel="dns-prefetch" href="//cdn.jsdelivr.net">
  <link rel="stylesheet" id="saukra_css-css" href="/css/style.css" type="text/css" media="all">
  <link rel="stylesheet" href="/css/lib.min.css" media="all">
  <link rel="stylesheet" href="/css/font.css" media="all">
  <link rel="stylesheet" href="/css/insight.css" media="all">
  <link rel="stylesheet" href="/css/jquery.fancybox.min.css" media="all">
  <link rel="stylesheet" href="/css/zoom.css" media="all">
  <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
  
  <!-- 自定义logo -->
  <link rel="stylesheet" type="text/css" href="/css/logo.css">
  <link rel="stylesheet" type="text/css" href="/fonts/LOGO/logo.css">
  
<!--   <link rel="stylesheet" id="saukra_css-css" href="https://2heng.xin/wp-content/cache/autoptimize/css/autoptimize_ad42a61f4c7d4bdd9f91afcff6b5dda5.css
" type="text/css" media="all"> -->
  <script>
  /*Initial Variables*/
  var mashiro_option = new Object();
  var mashiro_global = new Object();
  mashiro_option.NProgressON = true;
  /* 
   * 邮箱信息之类的东西可以填在这里，这些js变量基本都作用于sakura-app.js
   * 这样的设置仅是为了方便在基于PHP开发的主题中设置js变量，既然移植到了Node上，我想或许可以精简这一逻辑吧
   */
  mashiro_option.email_domain = "";
  mashiro_option.email_name = "";
  mashiro_option.cookie_version_control = "";
  mashiro_option.qzone_autocomplete = false;
  mashiro_option.site_name = "樱花庄的臭鸽子:D";
  mashiro_option.author_name = ":D";
  mashiro_option.site_url = "https://lkarrie.com";
  mashiro_option.v_appId = "XimjXrztzD4IysJIh75YxAAX-gzGzoHsz";
  mashiro_option.v_appKey = "khl1hWHMQg21hOiDrW4UCqt1";
  mashiro_option.mathjax = "0";
  mashiro_option.qq_api_url = "https://api.mashiro.top/qqinfo/"; 
  mashiro_option.qq_avatar_api_url = "https://api.mashiro.top/qqinfo/";

  // mashiro_option.jsdelivr_css_src = "https://cdn.jsdelivr.net/gh/moezx/cdn@3.4.5/css/lib.min.css";
  // mashiro_option.float_player_on = true;

  /*End of Initial Variables*/
  </script>
  <script type="text/javascript">
  var bg = "https://cdn.jsdelivr.net/gh/LKarrie/CDN/img/cover/66474729_p0.jpg.webp,https://cdn.jsdelivr.net/gh/LKarrie/CDN/img/cover/67243791_p0.jpg.webp,https://cdn.jsdelivr.net/gh/LKarrie/CDN/img/cover/68656805_p0.jpg.webp".split(",");
  var bgindex = Math.floor(Math.random()*bg.length);
  if (!!window.ActiveXObject || "ActiveXObject" in window) { //is IE?
    alert('朋友，IE浏览器未适配哦~');
  }
  </script>
  <style type="text/css">
  .hljs-ln{border-collapse:collapse}.hljs-ln td{padding:0}.hljs-ln-n:before{content:attr(data-line-number)}
  </style>
  <style type="text/css">.site-top .lower nav{display:block !important;}.author-profile i,.post-like a,.post-share .show-share,.sub-text,.we-info a,span.sitename,.post-more i:hover,#pagination a:hover,.post-content a:hover,.float-content i:hover{color:#FE9600}.feature i,.download,.navigator i:hover,.links ul li:before,.ar-time i,span.ar-circle,.object,.comment .comment-reply-link,.siren-checkbox-radio:checked + .siren-checkbox-radioInput:after{background:#FE9600}::-webkit-scrollbar-thumb{background:#FE9600}.download,.navigator i:hover,.link-title,.links ul li:hover,#pagination a:hover,.comment-respond input[type='submit']:hover{border-color:#FE9600}.entry-content a:hover,.site-info a:hover,.comment h4 a,#comments-navi a.prev,#comments-navi a.next,.comment h4 a:hover,.site-top ul li a:hover,.entry-title a:hover,#archives-temp h3,span.page-numbers.current,.sorry li a:hover,.site-title a:hover,i.iconfont.js-toggle-search.iconsearch:hover,.comment-respond input[type='submit']:hover{color:#FE9600}.comments .comments-main{display:block !important;}.comments .comments-hidden{display:none !important;}background-position:center center;background-attachment:inherit;}
  </style>
</head>
</html>
<body class="page-template page-template-user page-template-page-analytics page-template-userpage-analytics-php page page-id-1297 chinese-font serif isWebKit">
  <div class="scrollbar" id="bar">
  </div>
  <a href="#" class="cd-top faa-float animated"></a>
  <section id="main-container">
    <div class="headertop filter-dot">
  <div id="banner_wave_1"></div>
  <div id="banner_wave_2"></div>
  <figure id="centerbg" class="centerbg">
    <div class="focusinfo no-select">
      <!-- 头像 -->
      <!-- <div class="header-tou">
        <a href="https://lkarrie.com">
          <img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/img/custom/avatar2.jpg">
        </a>
      </div> -->
      <div class="header-tou">
        <h1 class="center-text glitch is-glitching Ubuntu-font" data-text="HI,LKARRIE">HI,LKARRIE</h1>
     </div>
      <div class="header-info">
        <p><i class="fa fa-quote-left"></i> World.Execute(me); <i class="fa fa-quote-right"></i></p>
        <!-- <p> World.Execute(me); </p> -->
        <div class="top-social_v2">
          <li id="bg-pre">
            <img class="flipx" src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/img/other/next-b.svg">
          </li>
          
            
              
                <li>
                  <a href="http://github.com/LKarrie" target="_blank" class="social-github" title="github">
                    <img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/img/social/github.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="https://weibo.com/u/6707437821?refer_flag=1001030103_&amp;is_all=1" target="_blank" class="social-github" title="sina">
                    <img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/img/social/sina.png">
                  </a>
                </li>
              
            
              
                <li class="wechat">
                  <a href="/#">
                    <img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/img/social/wechat.png">
                  </a>
                  <div class="wechatInner">
                    <img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/img/custom/wechat.jpg">
                  </div>
                </li>
              
            
              
                <li class="wechat">
                  <a href="/#">
                    <img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/img/social/qq.png">
                  </a>
                  <div class="wechatInner">
                    <img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/img/custom/qq.jpg">
                  </div>
                </li>
              
            
          
          <li id="bg-next">
            <img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/img/other/next-b.svg">
          </li>
        </div>
      </div>
    </div>
  </figure>
  <div id="video-container" style="">
    <video style="object-fit: fill" id="bgvideo" class="video" video-name="" src="" width="auto" preload="auto">
    </video>
    <div id="video-btn" class="loadvideo videolive">
    </div>
    <div id="video-add">
    </div>
    <div class="video-stu">
    </div>
  </div>
  <div class="headertop-down faa-float animated" onclick="headertop_down()">
    <span>
      <i class="fa fa-chevron-down" aria-hidden="true">
      </i>
    </span>
  </div>
</div>
    <div id="page" class="site wrapper">
      <header class="site-header no-select gizle sabit" role="banner">
  <div class="site-top">
    <div class="site-branding">
	  <span class="site-title">
		<span class="logolink logo">
			<a href="/">
				<ruby>
				<span class="sakuraso">さくら荘</span>
				<span class="no">の</span>
				<span class="shironeko">咕咕</span>
				<rp></rp>
				<rt class="logo">樱花庄的臭鸽子</rt>
				<rp></rp>
				</ruby>
			</a>
		</span>
	  </span>
    </div>
    <div class="searchbox search-form-submit">
      <i class="iconfont js-toggle-search iconsearch icon-search">
      </i>
    </div>
    <div id="show-nav" class="showNav mobile-fit">
      <div class="line line1">
      </div>
      <div class="line line2">
      </div>
      <div class="line line3">
      </div>
    </div>
    <div class="lower-cantiner">
      <div class="lower">
        <nav class="mobile-fit-control hide">
          <ul id="menu-new" class="menu">
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
                    首页
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/archives">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
                    归档
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/categories/技术/">
                          <i class="fa fa-code" aria-hidden="true"></i>
                          技术
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/随想/">
                          <i class="fa fa-commenting-o" aria-hidden="true"></i>
                          随想
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="javascript:;">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
                    标签
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/tags/前端/">
                          <i class="fa fa-window-maximize" aria-hidden="true"></i>
                          前端
                        </a>
                      </li>
                    
                      <li>
                        <a href="/tags/后端/">
                          <i class="fa fa-leaf" aria-hidden="true"></i>
                          后端
                        </a>
                      </li>
                    
                      <li>
                        <a href="/tags/系统/">
                          <i class="fa fa fa-linux" aria-hidden="true"></i>
                          系统
                        </a>
                      </li>
                    
                      <li>
                        <a href="/tags/容器/">
                          <i class="fa fa-cubes" aria-hidden="true"></i>
                          容器
                        </a>
                      </li>
                    
                      <li>
                        <a href="/tags/测试/">
                          <i class="fa fa-bar-chart" aria-hidden="true"></i>
                          测试
                        </a>
                      </li>
                    
                      <li>
                        <a href="/tags/K8S/">
                          <i class="fa fa-cloud" aria-hidden="true"></i>
                          K8S
                        </a>
                      </li>
                    
                      <li>
                        <a href="/tags/DBA/">
                          <i class="fa fa-database" aria-hidden="true"></i>
                          DBA
                        </a>
                      </li>
                    
                      <li>
                        <a href="/tags/其他/">
                          <i class="fa fa-meh-o" aria-hidden="true"></i>
                          其他
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="/resource/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-archive faa-horizontal" aria-hidden="true"></i>
                    资源
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/game/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-server faa-bounce" aria-hidden="true"></i>
                    游戏
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/comment/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
                    留言板
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="javascript:;">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-heart faa-wrench" aria-hidden="true"></i>
                    关于
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/about/">
                          <i class="fa fa-user-o" aria-hidden="true"></i>
                          我?
                        </a>
                      </li>
                    
                      <li>
                        <a href="/theme-sakura/">
                          <i class="fa iconfont icon-sakura" aria-hidden="true"></i>
                          主题
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="/mikutap/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-music faa-shake" aria-hidden="true"></i>
                    Miku
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/steamgames/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-steam-square faa-shake" aria-hidden="true"></i>
                    蒸汽
                  </span>
                </a>
                
              </li>
            
          </ul>
        </nav>
      </div>
    </div>
  </div>
</header>

      <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
<div class="pattern-center-blank"></div>

  <div class="pattern-center single-center">
    <!-- 有配图默认渲染第一张 -->
    <div class="pattern-attachment-img lazyload" style="background-image: url(https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/84036478_p0.jpg);" src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/img/loader/orange.progress-bar-stripe-loader.svg" data-src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/84036478_p0.jpg">
    </div>
    <header class="pattern-header single-header">
      <h1 class="entry-title">
      docker</h1>
      <p class="entry-census">
        <span>
          <a href="lkarrie.com">
            <img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/img/custom/avatar2.jpg">
          </a>
        </span>
        <span>
          <a href="lkarrie.com">lkarrie</a>
        </span>
        <span class="bull">
        ·</span>
        2021-6-20<span class="bull">
        ·</span>
      <span id="busuanzi_value_page_pv"></span>次阅读</p>
    </header>
  </div>

<div id="content" class="site-content">
  <div id="primary" class="content-area">
    <main id="main" class="site-main" role="main">
      <article id="post-1" class="post-1 post type-post status-publish format-standard has-post-thumbnail hentry category-uncategorized">
        <div class="toc"></div>
        <!--<div class="toc-entry-content"><!-- 套嵌目录使用（主要为了支援评论）-->
        
        <div class="entry-content">
          <h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h2><p>Docker虽然平时工作上我也经常使用，但是并不是真正的精通，最近抽空又重新学习了一遍</p>
<p>本篇的内容是我在一位优秀的前辈  <a href="https://space.bilibili.com/352224540?spm_id_from=333.788.b_765f7570696e666f.1" target="_blank" rel="noopener">编程不良人</a> 的笔记之上，整合自己的学习和理解添加补充修改后形成</p>
<p>封面<a href="https://www.pixiv.net/artworks/84036478" target="_blank" rel="noopener">Skadi</a>出自<a href="https://www.pixiv.net/users/3654697" target="_blank" rel="noopener">KR</a></p>
<ul>
<li><a href="https://www.docker.com/get-started" target="_blank" rel="noopener">官方文档地址</a></li>
<li><a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a></li>
<li><a href="https://docker_practice.gitee.io/zh-cn/" target="_blank" rel="noopener">参考中文文档地址</a>（中文文档也不太好用，网页点不动…）</li>
<li><a href="https://download.docker.com/linux/static/stable/x86_64/" target="_blank" rel="noopener">离线Docker二进制文件包下载</a></li>
</ul>
<h2 id="1-什么是-Docker"><a href="#1-什么是-Docker" class="headerlink" title="1.什么是 Docker"></a>1.什么是 Docker</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><pre><code class="markdown"># 官方介绍
- We have a complete container solution for you - no matter who you are and where you are on your containerization journey.
- 翻译: 我们为你提供了一个完整的容器解决方案,不管你是谁,不管你在哪,你都可以开始容器的的旅程。
- 官方定义: docker是一个容器技术。

# 底层
- Docker使用Google公司推出的 Go语言 进行开发实现，基于 Linux 内核的 cgroup、namespace 以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程,因此也称其为容器。
- Docker是一个CS架构，有分客户端和服务器端，详细你可以docker info 可以看出来 client和server
</code></pre>
<h2 id="2-Docker和虚拟机区别"><a href="#2-Docker和虚拟机区别" class="headerlink" title="2.Docker和虚拟机区别"></a>2.Docker和虚拟机区别</h2><p>关于Docker与虚拟机的区别下面的图已经说的很清楚了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/image-20201220222456675.png" alt="image-20201220222456675"></p>
<p><code>比较上面两张图，我们发现虚拟机是携带操作系统，本身很小的应用程序却因为携带了操作系统而变得非常大，很笨重</code>。Docker是不携带操作系统的，所以Docker的应用就非常的轻巧。另外在调用宿主机的CPU、磁盘等等这些资源的时候，拿内存举例，虚拟机是利用Hypervisor去虚拟化内存，整个调用过程是虚拟内存-&gt;虚拟物理内存-&gt;真正物理内存，但是Docker是利用Docker Engine去调用宿主的的资源，这时候过程是虚拟内存-&gt;真正物理内存。</p>
<table>
<thead>
<tr>
<th></th>
<th>传统虚拟机</th>
<th>Docker容器</th>
</tr>
</thead>
<tbody>
<tr>
<td>磁盘占用</td>
<td>几个GB到几十个GB左右</td>
<td>几十MB到几百MB左右</td>
</tr>
<tr>
<td>CPU内存占用</td>
<td>虚拟操作系统非常占用CPU和内存</td>
<td>Docker引擎占用极低</td>
</tr>
<tr>
<td>启动速度</td>
<td>（从开机到运行项目）几分钟</td>
<td>（从开启容器到运行项目）几秒</td>
</tr>
<tr>
<td>安装管理</td>
<td>需要专门的运维技术</td>
<td>安装、管理方便</td>
</tr>
<tr>
<td>应用部署</td>
<td>每次部署都费时费力</td>
<td>从第二次部署开始轻松简捷</td>
</tr>
<tr>
<td>耦合性</td>
<td>多个应用服务安装到一起，容易互相影响</td>
<td>每个应用服务一个容器，达成隔离</td>
</tr>
<tr>
<td>系统依赖</td>
<td>无</td>
<td>需求相同或相似的内核，目前推荐是Linux</td>
</tr>
</tbody>
</table>
<h2 id="3-Docker的安装"><a href="#3-Docker的安装" class="headerlink" title="3.Docker的安装"></a>3.Docker的安装</h2><h3 id="3-1-相关网站"><a href="#3-1-相关网站" class="headerlink" title="3.1 相关网站"></a>3.1 相关网站</h3><p><a href="https://docs.docker.com/engine/install/" target="_blank" rel="noopener">官方安装文档</a></p>
<h3 id="3-2-在线安装Docker-centos7-x"><a href="#3-2-在线安装Docker-centos7-x" class="headerlink" title="3.2 在线安装Docker(centos7.x)"></a>3.2 在线安装Docker(centos7.x)</h3><p>注意：Docker只兼容centos7以及之后的版本，centos6？对不起不行，不支持</p>
<ul>
<li><p>卸载原始docker</p>
<pre><code class="sh">$ sudo yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
</code></pre>
</li>
<li><p>安装docker依赖</p>
<pre><code class="shell">$ sudo yum install -y yum-utils \
  device-mapper-persistent-data \
  lvm2
</code></pre>
</li>
<li><p>设置docker的yum源</p>
<pre><code class="bash">$ sudo yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo
</code></pre>
</li>
<li><p>安装最新版的docker</p>
<pre><code class="bash">$ sudo yum install docker-ce docker-ce-cli containerd.io
</code></pre>
</li>
<li><p>指定版本安装docker</p>
<pre><code class="bash">$ yum list docker-ce --showduplicates | sort -r
$ sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io
$ sudo yum install docker-ce-18.09.5-3.el7 docker-ce-cli-18.09.5-3.el7 containerd.io
</code></pre>
</li>
<li><p>启动docker</p>
<pre><code class="bash"># 开机自启
$ sudo systemctl enable docker
$ sudo systemctl start docker
</code></pre>
</li>
<li><p>关闭docker</p>
<pre><code class="bash">$ sudo systemctl stop docker
</code></pre>
</li>
<li><p>测试docker安装</p>
<pre><code class="bash">$ sudo docker run hello-world
</code></pre>
</li>
</ul>
<h3 id="3-3-在线bash安装-通用所有平台"><a href="#3-3-在线bash安装-通用所有平台" class="headerlink" title="3.3 在线bash安装(通用所有平台)"></a>3.3 在线bash安装(通用所有平台)</h3><ul>
<li><p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装，另外可以通过 <code>--mirror</code> 选项使用国内源进行安装：执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。</p>
<pre><code class="bash"># 下载脚本文件
$ curl -fsSL get.docker.com -o get-docker.sh
# 安装
$ sudo sh get-docker.sh --mirror Aliyun
</code></pre>
</li>
<li><p>启动docker</p>
<pre><code class="bash">$ sudo systemctl enable docker
$ sudo systemctl start docker
</code></pre>
</li>
<li><p>创建docker用户组并将当前用户加入docker组</p>
<pre><code class="bash">$ sudo groupadd docker
$ sudo usermod -aG docker $USER
</code></pre>
<p><strong>注意</strong>：创建docker的专用用户和用户组并不是必须的操作，只是官方的建议（我自己就从来没有建过，直接拿root耍，hahah）</p>
</li>
</ul>
<p>  <strong>为什么要建立docker的专用用户？</strong></p>
<p>  默认情况下，docker命令会使用Unix socket与docker 引擎通信，而只有 root 用户和 docker 组的用户才能访问docker引擎的 Unix socket。出于安全考虑，一般Linux系统上不会直接使用 root 用户。因此，更好的方法是将需要使用的 docker的用户 加入docker 用户组~</p>
<ul>
<li><p>测试docker安装是否正确</p>
<pre><code class="bash">$ docker run hello-world
</code></pre>
</li>
</ul>
<h3 id="3-4-离线安装Docker"><a href="#3-4-离线安装Docker" class="headerlink" title="3.4 离线安装Docker"></a>3.4 离线安装Docker</h3><ul>
<li><p>查看内核 内核版本需要3.10.0以上</p>
<pre><code class="sh">uname -a

cat /proc/version
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/image-20210611104523298.png" alt="image-20210611104523298"></p>
</li>
<li><p>关闭selinux 修改SELINUX的值为 disabled</p>
<pre><code class="sh">vi  /etc/selinux/config
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/image-20210611104552530.png" alt="image-20210611104552530"></p>
</li>
<li><p>关闭防火墙</p>
<pre><code class="sh">systemctl status firewalld

systemctl stop firewalld

systemctl disable firewalld

reboot
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/image-20210611104704173.png" alt="image-20210611104704173"></p>
</li>
<li><p>创建安装的位置（目录根据实际来调整 最好放在最大的挂载下）</p>
<pre><code class="sh">df -h

mkdir -p /app/docker
</code></pre>
</li>
<li><p>复制文件到服务器的/usr/bin目录，也可以使用xftp传送到/usr/bin</p>
<pre><code class="sh">cd docker-18.06.1-ce/
cp docker/* /usr/bin/

chmod +x /usr/bin/docker* 
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/image-20210611104945586.png" alt="image-20210611104945586"></p>
</li>
<li><p>配置docker的 daemon.json</p>
<pre><code class="sh">mkdir -p /etc/docker
cd /etc/docker
vi /etc/docker/daemon.json
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/image-20210611105242925.png" alt="image-20210611105242925"></p>
<p><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/image-20210611105138663.png" alt="image-20210611105138663"></p>
</li>
<li><p>配置举例</p>
<pre><code class="json">{
    &quot;data-root&quot;:&quot;docker目录位置，自行设置，磁盘要够大&quot;,
    &quot;insecure-registries&quot;: [&quot;不含证书的镜像仓库地址可以是多个&quot;, &quot;如: 192.168.137.111:4000&quot;]
}
</code></pre>
</li>
<li><p>配置样例</p>
<pre><code class="json">
{
    &quot;data-root&quot;:&quot;/app/docker&quot;
}
</code></pre>
</li>
<li><p>将docker设置为开机自启并查看docker</p>
<pre><code class="sh">cp docker.service /usr/lib/systemd/system/
systemctl daemon-reload
systemctl enable docker
systemctl start docker

docker -v
docker info
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/image-20210611105343530.png" alt="image-20210611105343530"></p>
<p><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/image-20210611105603793.png" alt="image-20210611105603793"></p>
</li>
<li><p>Docker 用户创建（用root可以不做，创建参考在线安装）</p>
</li>
</ul>
<h2 id="4-Docker-的核心架构"><a href="#4-Docker-的核心架构" class="headerlink" title="4.Docker 的核心架构"></a>4.Docker 的核心架构</h2><p><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/image-20200404111908085-0291323.png" alt="image-20200404111908085"></p>
<ul>
<li><code>镜像:</code> 一个镜像代表一个应用环境,他是一个只读的文件,如 mysql镜像,tomcat镜像,nginx镜像等</li>
<li><code>容器:</code> 镜像每次运行之后就是产生一个容器,就是正在运行的镜像,特点就是可读可写</li>
<li><code>仓库:</code>用来存放镜像的位置,类似于maven仓库,也是镜像下载和上传的位置</li>
<li><code>dockerFile:</code>docker生成镜像配置文件,用来书写自定义镜像的一些配置</li>
<li><code>tar:</code>一个对镜像打包的文件,日后可以还原成镜像</li>
</ul>
<h2 id="5-Docker-配置阿里镜像加速服务"><a href="#5-Docker-配置阿里镜像加速服务" class="headerlink" title="5.Docker 配置阿里镜像加速服务"></a>5.Docker 配置阿里镜像加速服务</h2><h3 id="5-1-docker-运行流程"><a href="#5-1-docker-运行流程" class="headerlink" title="5.1 docker 运行流程"></a>5.1 docker 运行流程</h3><p><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/image-20200404120356784.png" alt="image-20200404120356784"></p>
<h3 id="5-2-docker配置阿里云镜像加速-可选"><a href="#5-2-docker配置阿里云镜像加速-可选" class="headerlink" title="5.2 docker配置阿里云镜像加速(可选)"></a>5.2 docker配置阿里云镜像加速(可选)</h3><ul>
<li><p>访问阿里云登录自己账号查看docker镜像加速服务</p>
<p><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/image-20210607191846559.png" alt="image-20210607191846559"></p>
</li>
</ul>
<pre><code class="shell"># 设置 仓库地址替换成自己的~

sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39;
{
  &quot;registry-mirrors&quot;: [&quot;https://your.mirror.aliyuncs.com&quot;]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker
</code></pre>
<ul>
<li><code>验证docker的镜像加速是否生效</code></li>
</ul>
<pre><code class="shell">[root@localhost ~]# docker info
        ..........
    127.0.0.0/8
   Registry Mirrors:
    &#39;https://your.mirror.aliyuncs.com/&#39;
   Live Restore Enabled: false
   Product License: Community Engine
</code></pre>
<h2 id="6-Hello-world"><a href="#6-Hello-world" class="headerlink" title="6.Hello-world"></a>6.Hello-world</h2><h3 id="6-1-docker-的第一个容器"><a href="#6-1-docker-的第一个容器" class="headerlink" title="6.1 docker 的第一个容器"></a>6.1 docker 的第一个容器</h3><p><strong>docker  run hello-world</strong></p>
<pre><code class="shell">[root@localhost ~]# docker run hello-world

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/
</code></pre>
<h2 id="7-常用命令"><a href="#7-常用命令" class="headerlink" title="7.常用命令"></a>7.常用命令</h2><h3 id="7-1-辅助命令"><a href="#7-1-辅助命令" class="headerlink" title="7.1 辅助命令"></a>7.1 辅助命令</h3><pre><code class="markdown"># 1.安装完成辅助命令
        docker version    --------------------------    查看docker的信息
        docker info        --------------------------    查看更详细的信息
        docker --help    --------------------------    帮助命令
</code></pre>
<h3 id="7-2-Images-镜像命令"><a href="#7-2-Images-镜像命令" class="headerlink" title="7.2 Images 镜像命令"></a>7.2 Images 镜像命令</h3><pre><code class="markdown"># 1.查看本机中所有镜像
    docker images    --------------------------    列出本地所有镜像
        -a            列出所有镜像（包含中间映像层）
      -q            只显示镜像id

# 2.搜索镜像
    docker search [options] 镜像名    -------------------    去dockerhub上查询当前镜像
        -s 指定值        列出收藏数不少于指定值的镜像
      --no-trunc      显示完整的镜像信息

# 3.从仓库下载镜像
    docker pull 镜像名[:TAG|@DIGEST]    ----------------- 下载镜像

# 4.删除镜像
    docker rmi 镜像名    --------------------------  删除镜像
        -f        强制删除
</code></pre>
<h3 id="7-3-Container-容器命令"><a href="#7-3-Container-容器命令" class="headerlink" title="7.3 Container 容器命令"></a>7.3 Container 容器命令</h3><pre><code class="markdown"># 1.运行容器
    docker run 镜像名    --------------------------    镜像名新建并启动容器
    --name                     别名为容器起一个名字（自定义了dns解析，同一网桥下可以使用名称访问ip）
    -d                            启动守护式容器（在后台启动容器）
    -p                             映射端口号：原始端口号         指定端口号启动
        --ip 172.18.0.2 指定ip（网桥下）
        --network bridge 指定网络模式
        -it                         直接以交互模式启动（进容器里了）
    例：docker run -it --name myTomcat -p 8888:8080 tomcat
        docker run -d --name myTomcat -P tomcat

# 2.docker run --privileged=true 参数作用
    使用该参数，container内的root拥有真正的root权限。
    否则，container内的root只是外部的一个普通用户权限。
    privileged启动的容器，可以看到很多host上的设备，并且可以执行mount。
    甚至允许你在docker容器中启动docker容器。

# 3.docker run -d 参数作用
    启动后直接返回容器id，不以终端的形式运行容器（终端 ctrl+c 就直接退出了）

# 4.查看运行的容器
    docker ps                    --------------------------    列出所有正在运行的容器
    -a            正在运行的和历史运行过的容器
    -q            静默模式，只显示容器编号
    docker ps -qa

# 5.停止|关闭|重启容器
    docker start   容器名字或者容器id  --------------- 开启容器
    docker restart 容器名或者容器id    --------------- 重启容器
    docker stop  容器名或者容器id         ------------------ 正常停止容器运行
    docker kill  容器名或者容器id      ------------------ 立即停止容器运行

# 6.删除容器
    docker rm -f 容器id和容器名     
    docker rm -f $(docker ps -aq)        --------------------------    删除所有容器

# 7.查看容器内进程
    docker top 容器id或者容器名 ------------------ 查看容器内的进程

# 8.查看查看容器内部细节
    docker inspect 容器id         ------------------ 查看容器内部细节
    docker inspect --format=&quot;{{.Id}}&quot; name   ------------------获取运行容器id

# 9.查看容器的运行日志
    docker logs [OPTIONS] 容器id或容器名    ------------------ 查看容器日志
    -t             加入时间戳
    -f             跟随最新的日志打印
    --tail      数字    显示最后多少条
    docker logs -t -f --tail=100 rabbitmq

# 10.进入容器内部
    docker exec [options] 容器id 容器内命令 ------------------ 进入容器执行命令
        -i        以交互模式运行容器，通常与-t一起使用
    -t        分配一个伪终端    shell窗口   bash 
    docker exec -it rabbitmq bash

# 11.容器和宿主机之间复制文件
    docker cp 文件|目录 容器id:容器路径           -----------------   将宿主机复制到容器内部
    docker cp 容器id:容器内资源路径 宿主机目录路径  -----------------   将容器内资源拷贝到主机上

# 12.数据卷(volum)实现与宿主机共享目录
    docker run -v 宿主机的路径|任意别名:/容器内的路径 镜像名
    docker run -v 宿主机的路径|任意别名:/容器内的路径:ro 镜像名-&gt; 容器内目录只读（容器不能操作这个目录）
        注意（理解这个非常重要）: 
                1.如果是宿主机路径必须是绝对路径,宿主机目录会覆盖容器内目录内容
                2.如果是别名则会在docker运行容器时自动在宿主机中创建一个目录,并将容器目录文件复制到宿主机中
        理解上面的注意点还是非常有用的。

# 13.打包镜像
    docker save 镜像名 -o  名称.tar

# 14.载入镜像
    docker load -i   名称.tar

# 15.容器打包成新的镜像（容器会暂停）
    docker commit -m &quot;描述信息&quot; -a &quot;作者信息&quot;   （容器id或者名称）打包的镜像名称:标签

# 16.打包(dockerfile) 不要忘了后面的 . 这里指定的上下文目录，上下文目录为当前目录
    docker build -t vuenginxcontainer .
    docker build -t myctr:01 .

</code></pre>
<h2 id="8-Docker的镜像原理"><a href="#8-Docker的镜像原理" class="headerlink" title="8.Docker的镜像原理"></a>8.Docker的镜像原理</h2><h3 id="8-1-镜像是什么？"><a href="#8-1-镜像是什么？" class="headerlink" title="8.1 镜像是什么？"></a>8.1 镜像是什么？</h3><p>镜像是一种轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时所需的库、环境变量和配置文件。</p>
<h3 id="8-2-为什么一个镜像会那么大？"><a href="#8-2-为什么一个镜像会那么大？" class="headerlink" title="8.2 为什么一个镜像会那么大？"></a>8.2 为什么一个镜像会那么大？</h3><p><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/image-20200404142950068.png" alt="image-20200404142950068"></p>
<p><code>镜像就是花卷</code></p>
<ul>
<li><p>UnionFS（联合文件系统）:</p>
<p>Union文件系统是一种分层，轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统是Docker镜像的基础。这种文件系统特性:就是一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 。    </p>
</li>
</ul>
<h3 id="8-3-Docker镜像原理"><a href="#8-3-Docker镜像原理" class="headerlink" title="8.3 Docker镜像原理"></a>8.3 Docker镜像原理</h3><p><code>docker的镜像实际是由一层一层的文件系统组成（由一层一层的镜像构成）。</code></p>
<ul>
<li><p>bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统。在docker镜像的最底层就是bootfs。这一层与Linux/Unix 系统是一样的，包含boot加载器（bootloader）和内核（kernel）。当boot加载完,后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时会卸载bootfs。</p>
</li>
<li><p>rootfs（root file system），在bootfs之上，包含的就是典型的linux系统中的/dev，/proc，/bin，/etc等标准的目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu/CentOS等等。</p>
</li>
<li><p>我们平时安装进虚拟机的centos都有1到几个GB，为什么docker这里才200MB？对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令，工具，和程序库就可以了，因为底层直接使用Host的Kernal，自己只需要提供rootfs就行了。由此可见不同的linux发行版，他们的bootfs是一致的，rootfs会有差别。因此不同的发行版可以共用bootfs。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/1567585172.jpg" alt></p>
<p>当你在拉取镜像的时候也可以看出，拉取的时候是一层层拉取的，最上层则是最基础最公共的基础镜像</p>
<p><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/image-20210607203632213.png" alt="image-20210607203632213"></p>
<h3 id="8-4-为什么docker镜像要采用这种分层结构呢"><a href="#8-4-为什么docker镜像要采用这种分层结构呢" class="headerlink" title="8.4 为什么docker镜像要采用这种分层结构呢?"></a>8.4 为什么docker镜像要采用这种分层结构呢?</h3><p><code>最大的一个好处就是资源共享</code></p>
<ul>
<li>比如：有多个镜像都是从相同的base镜像构建而来的，那么宿主机只需在磁盘中保存一份base镜像。同时内存中也只需要加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。Docker镜像都是只读的。当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称为容器层，容器层之下都叫镜像层。</li>
</ul>
<h2 id="9-高级网络配置（非常重要）"><a href="#9-高级网络配置（非常重要）" class="headerlink" title="9.高级网络配置（非常重要）"></a>9.高级网络配置（非常重要）</h2><h3 id="9-1-说明"><a href="#9-1-说明" class="headerlink" title="9.1 说明"></a>9.1 说明</h3><p>当 Docker 启动时，会自动在主机上创建一个 <code>bridge</code> 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p>
<p>同时，Docker 随机分配一个本地未占用的私有网段（在 <a href="https://tools.ietf.org/html/rfc1918" target="_blank" rel="noopener">RFC1918</a> 中定义）中的一个地址给 <code>docker0</code> 接口。比如典型的 <code>172.17.42.1</code>，掩码为 <code>255.255.0.0</code>。此后启动的容器内的网口也会自动分配一个同一网段（<code>172.17.0.0/16</code>）的地址。</p>
<p>当创建一个 Docker 容器的时候，同时会创建了一对 <code>veth pair</code> 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 <code>eth0</code>；另一端在本地并被挂载到 <code>bridge</code> 网桥，名称以 <code>veth</code> 开头（例如 <code>vethAQI2QT</code>）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。</p>
<p><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/image-20201125105847896.png" alt="image-20201125105847896"></p>
<h3 id="9-2-查看网络信息"><a href="#9-2-查看网络信息" class="headerlink" title="9.2 查看网络信息"></a>9.2 查看网络信息</h3><pre><code class="markdown"># docker network ls
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/image-20210607204611435.png" alt="image-20210607204611435"></p>
<p>​    上面的图中可以看到docker的三种网络模式，bridge、host（容器的网络配置与host完全一样，在容器中可以看到host的所有网卡，而且hostname也和宿主机保持一致）、none（封闭网络，自闭模式hhh），默认容器都是使用bridge。实际应用中并不是所有容器都挂到默认的bridge网桥上就行了，如果有其中一个容器与外部交互非常频繁，会给默认的bridge带来较大的压力，由于别的容器也是公用这一个网桥，这样也就会影响到别的容器和外部的通信。我们要根据实际情况来决定使用一个默认的网桥是否合理。</p>
<h3 id="9-3-创建一个网桥"><a href="#9-3-创建一个网桥" class="headerlink" title="9.3 创建一个网桥"></a>9.3 创建一个网桥</h3><pre><code class="markdown"># docker network create -d bridge 网桥名称
</code></pre>
<h3 id="9-4-删除一个网桥"><a href="#9-4-删除一个网桥" class="headerlink" title="9.4 删除一个网桥"></a>9.4 删除一个网桥</h3><pre><code class="markdown"># docker network rm 网桥名称
</code></pre>
<h3 id="9-5-容器之间使用网络通信"><a href="#9-5-容器之间使用网络通信" class="headerlink" title="9.5 容器之间使用网络通信"></a>9.5 容器之间使用网络通信</h3><pre><code class="markdown"># 1.查询当前网络配置
- docker network ls
</code></pre>
<pre><code class="shell">NETWORK ID          NAME                DRIVER              SCOPE
8e424e5936b7        bridge              bridge              local
17d974db02da        docker_gwbridge     bridge              local
d6c326e433f7        host                host                local
</code></pre>
<pre><code class="markdown"># 2.创建桥接网络
- docker network create -d bridge info
</code></pre>
<pre><code class="shell">[root@centos ~]# docker network create -d bridge info
6e4aaebff79b1df43a064e0e8fdab08f52d64ce34db78dd5184ce7aaaf550a2f
[root@centos ~]# docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
8e424e5936b7        bridge              bridge              local
17d974db02da        docker_gwbridge     bridge              local
d6c326e433f7        host                host                local
6e4aaebff79b        info                bridge              local
</code></pre>
<pre><code class="markdown"># 3.启动容器指定使用网桥
- docker run -d -p 8890:80 --name nginx001 --network info nginx 
- docker run -d -p 8891:80 --name nginx002 --network info nginx 
    `注意:一旦指定网桥后--name指定名字就是主机名,多个容器指定在同一个网桥时,可以在任意一个容器中使用主机名与容器进行互通`
</code></pre>
<pre><code class="shell">[root@centos ~]# docker run -d -p 8890:80 --name nginx001 --network info nginx 
c315bcc94e9ddaa36eb6c6f16ca51592b1ac8bf1ecfe9d8f01d892f3f10825fe
[root@centos ~]# docker run -d -p 8891:80 --name nginx002 --network info nginx
f8682db35dd7fb4395f90edb38df7cad71bbfaba71b6a4c6e2a3a525cb73c2a5
[root@centos ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES
f8682db35dd7        nginx               &quot;/docker-entrypoint.…&quot;   3 seconds ago       Up 2 seconds        0.0.0.0:8891-&gt;80/tcp   nginx002
c315bcc94e9d        nginx               &quot;/docker-entrypoint.…&quot;   7 minutes ago       Up 7 minutes        0.0.0.0:8890-&gt;80/tcp   nginx001
b63169d43792        mysql:5.7.19        &quot;docker-entrypoint.s…&quot;   7 minutes ago       Up 7 minutes        3306/tcp               mysql_mysql.1.s75qe5kkpwwttyf0wrjvd2cda
[root@centos ~]# docker exec -it f8682db35dd7 /bin/bash
root@f8682db35dd7:/# curl http://nginx001
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
.....
</code></pre>
<h3 id="9-6-查看网桥信息"><a href="#9-6-查看网桥信息" class="headerlink" title="9.6 查看网桥信息"></a>9.6 查看网桥信息</h3><pre><code class="markdown"># 可以直接查看当前网桥的ip（网关gatwway）和在这个ip下活跃的容器 Containers标签存在容器即活跃
- docker inspect 网桥名称
</code></pre>
<p>举例：</p>
<pre><code class="shell">[root@worker2 ~]# docker network ls
NETWORK ID          NAME                     DRIVER              SCOPE
ef209b3f55ac        bridge                   bridge              local
d5d7fb7c733a        host                     host                local
9617f81ea7ed        metersphere_ms-network   bridge              local
b8fbeb5755fc        none                     null                local
[root@worker2 ~]# docker inspect metersphere_ms-network
[
    {
        &quot;Name&quot;: &quot;metersphere_ms-network&quot;,
        &quot;Id&quot;: &quot;9617f81ea7edc6e38e711dfea23ffaa0c8dc17df458c597213a52b389a3c480e&quot;,
        &quot;Created&quot;: &quot;2021-05-31T14:27:40.186875973+08:00&quot;,
        &quot;Scope&quot;: &quot;local&quot;,
        &quot;Driver&quot;: &quot;bridge&quot;,
        &quot;EnableIPv6&quot;: false,
        &quot;IPAM&quot;: {
            &quot;Driver&quot;: &quot;default&quot;,
            &quot;Options&quot;: null,
            &quot;Config&quot;: [
                {
                    &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;,
                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;
                }
            ]
        },
        &quot;Internal&quot;: false,
        &quot;Attachable&quot;: true,
        &quot;Ingress&quot;: false,
        &quot;ConfigFrom&quot;: {
            &quot;Network&quot;: &quot;&quot;
        },
        &quot;ConfigOnly&quot;: false,
        &quot;Containers&quot;: {
            &quot;73cd659e5bd5f772b6481319aba934043121329e0edf9a2e96e9ddc7e64d69b8&quot;: {
                &quot;Name&quot;: &quot;ms-node-controller&quot;,
                &quot;EndpointID&quot;: &quot;c787b3b08d33088df519b879a0cb4f96f56e1ac2c0647c4dfd8adaa6450d9bf4&quot;,
                &quot;MacAddress&quot;: &quot;02:42:ac:12:00:05&quot;,
                &quot;IPv4Address&quot;: &quot;172.18.0.5/16&quot;,
                &quot;IPv6Address&quot;: &quot;&quot;
            }
        },
        &quot;Options&quot;: {},
        &quot;Labels&quot;: {
            &quot;com.docker.compose.network&quot;: &quot;ms-network&quot;,
            &quot;com.docker.compose.project&quot;: &quot;metersphere&quot;
        }
    }
]
[root@worker2 ~]# 
</code></pre>
<h2 id="10-高级数据卷配置"><a href="#10-高级数据卷配置" class="headerlink" title="10.高级数据卷配置"></a>10.高级数据卷配置</h2><h3 id="10-1-说明"><a href="#10-1-说明" class="headerlink" title="10.1 说明"></a>10.1 说明</h3><p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p>
<ul>
<li><code>数据卷</code> 可以在容器之间共享和重用</li>
<li>对 <code>数据卷</code> 的修改会立马生效</li>
<li>对 <code>数据卷</code> 的更新，不会影响镜像</li>
<li><code>数据卷</code> 默认会一直存在，即使容器被删除</li>
</ul>
<blockquote>
<p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p>
</blockquote>
<h3 id="10-2-创建数据卷"><a href="#10-2-创建数据卷" class="headerlink" title="10.2 创建数据卷"></a>10.2 创建数据卷</h3><p>创建时不需要指定目录，这个数据卷会在docker root 目录下面生成~</p>
<pre><code class="shell">[root@centos ~]# docker volume create my-vol
my-vol
</code></pre>
<h3 id="10-3-查看数据卷"><a href="#10-3-查看数据卷" class="headerlink" title="10.3 查看数据卷"></a>10.3 查看数据卷</h3><pre><code class="shell">[root@centos ~]# docker volume inspect my-vol       
[
    {
        &quot;CreatedAt&quot;: &quot;2020-11-25T11:43:56+08:00&quot;,
        &quot;Driver&quot;: &quot;local&quot;,
        &quot;Labels&quot;: {},
        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,
        &quot;Name&quot;: &quot;my-vol&quot;,
        &quot;Options&quot;: {},
        &quot;Scope&quot;: &quot;local&quot;
    }
]
</code></pre>
<h3 id="10-4-挂载数据卷"><a href="#10-4-挂载数据卷" class="headerlink" title="10.4 挂载数据卷"></a>10.4 挂载数据卷</h3><pre><code class="shell">[root@centos ~]# docker run -d -P --name web  -v my-vol:/usr/share/nginx/html  nginx
[root@centos ~]# docker inspect web
                &quot;Mounts&quot;: [
            {
                &quot;Type&quot;: &quot;volume&quot;,
                &quot;Name&quot;: &quot;my-vol&quot;,
                &quot;Source&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,
                &quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;,
                &quot;Driver&quot;: &quot;local&quot;,
                &quot;Mode&quot;: &quot;z&quot;,
                &quot;RW&quot;: true,
                &quot;Propagation&quot;: &quot;&quot;
            }
        ],
</code></pre>
<h3 id="10-5-删除数据卷"><a href="#10-5-删除数据卷" class="headerlink" title="10.5 删除数据卷"></a>10.5 删除数据卷</h3><pre><code class="shell">docker volume rm my-vol
</code></pre>
<h2 id="11-Docker安装常用服务"><a href="#11-Docker安装常用服务" class="headerlink" title="11.Docker安装常用服务"></a>11.Docker安装常用服务</h2><h3 id="11-0-必读"><a href="#11-0-必读" class="headerlink" title="11.0 必读"></a>11.0 必读</h3><blockquote>
<p>下面的安装均是简单安装（单机/单节点）的方法，有些组件高级的集群部署或者是相关介绍和详细设置我就在其他文章里补吧，不然太多了…</p>
</blockquote>
<h3 id="11-1-安装mysql"><a href="#11-1-安装mysql" class="headerlink" title="11.1 安装mysql"></a>11.1 安装mysql</h3><pre><code class="markdown"># 1.拉取mysql镜像到本地
    docker pull mysql:tag (tag不加默认最新版本)

# 2.简单运行mysql服务
    docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d  mysql:tag

# 3.进入mysql容器
    docker exec -it 容器名称|容器id bash

# 4.外部查看mysql日志
    docker logs 容器名称|容器id

# 5.使用自定义配置参数
    docker run -d --name mysql \
    -v /root/mysql/conf.d:/etc/mysql/conf.d \
    -e MYSQL_ROOT_PASSWORD=root \
    mysql:tag

# 6.将容器数据位置与宿主机位置挂载保证数据安全
    docker run -p 3306:3306 -d --name mysql \
    -v /root/mysql/data:/var/lib/mysql \
    -v /root/mysql/conf.d:/etc/mysql/conf.d \
    -e MYSQL_ROOT_PASSWORD=root \
    mysql:tag

# 7.将mysql数据库备份为sql文件
    docker exec mysql|容器id sh -c &#39;exec mysqldump --all-databases -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#39; &gt; /root/all-databases.sql  --导出全部数据
    docker exec mysql sh -c &#39;exec mysqldump --databases 库表 -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#39; &gt; /root/all-databases.sql  --导出指定库数据
    docker exec mysql sh -c &#39;exec mysqldump --no-data --databases 库表 -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#39; &gt; /root/all-databases.sql  --导出指定库数据不要数据

# 8.执行sql文件到mysql中
    docker exec -i mysql sh -c &#39;exec mysql -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#39; &lt; /root/xxx.sql
</code></pre>
<h3 id="11-2-安装Redis服务"><a href="#11-2-安装Redis服务" class="headerlink" title="11.2 安装Redis服务"></a>11.2 安装Redis服务</h3><pre><code class="markdown"># 1.在docker hub搜索redis镜像
    docker search redis
    redis:5.0.10-alpine3.12, 这是最小的redis, 应为alpine是最小的linux操作系统 就几m

# 2.拉取redis镜像到本地
    docker pull redis

# 3.启动redis服务运行容器
    docker run --name redis -d redis:tag (没有暴露外部端口)
    docker run --name redis -p 6379:6379 -d redis:tag (暴露外部宿主机端口为6379进行连接) 

# 4.查看启动日志
    docker logs -t -f 容器id|容器名称

# 5.进入容器内部查看
    docker exec -it 容器id|名称 bash  

# 6.开启aof存储
    默认情况下快照备份也是默认开启的（dump.rdb），但是官方镜像介绍没有明确在哪，持久化可以使用aof
    docker run --name redis -d -v redisdata:/data redis:5.0.10 redis-server --appendonly yes
    开启持久化之后，持久化生成aof文件会被放入容器中的/data目录中（appendonly.aof）

# 6.加载外部自定义配置启动redis容器
    默认情况下redis官方镜像中没有redis.conf配置文件 需要去官网下载指定版本的配置文件 
    这些配置是在执行 redis-server 后再指定配置的位置后 生效
    1. wget http://download.redis.io/releases/redis-5.0.8.tar.gz  下载官方安装包
    2. 将官方安装包中配置文件进行复制到宿主机指定目录中如 /root/redis/redis.conf文件
    3. 修改需要自定义的配置
         bind 0.0.0.0 开启远程权限 不改redis manager连不上
         appenonly yes 开启aof持久化
    4. 加载配置启动
    docker run --name redis -v /root/redis:/usr/local/etc/redis -p 6379:6379 -d redis:5.0.10 redis-server /usr/local/etc/redis/redis.conf  

# 7.将数据目录挂在到本地保证数据安全
    docker run -p 6379:6379 -d --name redis \
    -v /root/redis/data:/data \
    -v /root/redis/redis.conf:/usr/local/etc/redis/redis.conf \
    redis:5.0.10 redis-server /usr/local/etc/redis/redis.conf
</code></pre>
<h3 id="11-3-安装Nginx"><a href="#11-3-安装Nginx" class="headerlink" title="11.3 安装Nginx"></a>11.3 安装Nginx</h3><pre><code class="markdown"># 1.在docker hub搜索nginx
    docker search nginx

# 2.拉取nginx镜像到本地
    [root@localhost ~]# docker pull nginx
    Using default tag: latest
    latest: Pulling from library/nginx
    afb6ec6fdc1c: Pull complete 
    b90c53a0b692: Pull complete 
    11fa52a0fdc0: Pull complete 
    Digest: sha256:30dfa439718a17baafefadf16c5e7c9d0a1cde97b4fd84f63b69e13513be7097
    Status: Downloaded newer image for nginx:latest
    docker.io/library/nginx:latest

# 3.启动nginx容器
        docker run -p 80:80 --name nginx01 -d nginx

# 4.进入容器
        docker exec -it nginx01 /bin/bash
        查找目录:  whereis nginx
        配置文件:  /etc/nginx/nginx.conf

# 5.复制配置文件到宿主机
        docker cp nginx01(容器id|容器名称):/etc/nginx/nginx.conf 宿主机名录

# 6.挂在nginx配置以及html到宿主机外部
        docker run -p 80:80 -d --name nginx02 \
        -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf \
        -v /root/nginx/html:/usr/share/nginx/html \
        nginx        
</code></pre>
<h3 id="11-4-安装Tomcat"><a href="#11-4-安装Tomcat" class="headerlink" title="11.4 安装Tomcat"></a>11.4 安装Tomcat</h3><pre><code class="markdown"># 1.在docker hub搜索tomcat
    docker search tomcat

# 2.下载tomcat镜像
    docker pull tomcat

# 3.运行tomcat镜像
    docker run -p 8080:8080 -d --name mytomcat tomcat

# 4.进入tomcat容器
    docker exec -it mytomcat /bin/bash

# 5.将webapps目录挂载在外部
    docker run -d --name mytomcat -p 8080:8080 \
    -v /root/webapps:/usr/local/tomcat/webapps \
    tomcat
# 6.数据卷启动    
    docker run -d --name tomcat -p 8080:8080 \
    -v apps:/usr/local/tomcat/webapps \
    -v confs:/usr/local/tomcat/conf \
    tomcat:8.0-jre8
</code></pre>
<h3 id="11-5-安装MongoDB数据库"><a href="#11-5-安装MongoDB数据库" class="headerlink" title="11.5 安装MongoDB数据库"></a>11.5 安装MongoDB数据库</h3><pre><code class="markdown"># 1.运行mongDB
    docker run -d -p 27017:27017 --name mymongo mongo  ---无须权限
    docker logs -f mymongo --查看mongo运行日志

# 2.进入mongodb容器
    docker exec -it mymongo /bin/bash
        直接执行mongo命令进行操作

# 3.常见具有权限的容器
    docker run --name  mymongo  -p 27017:27017  -d mongo --auth

# 4.进入容器配置用户名密码
    mongo
    use admin 选择admin库
    db.createUser({user:&quot;root&quot;,pwd:&quot;root&quot;,roles:[{role:&#39;root&#39;,db:&#39;admin&#39;}]})   //创建用户,此用户创建成功,则后续操作都需要用户认证
    exit

# 5.将mongoDB中数据目录映射到宿主机中
    docker run -d -p 27017:27017 -v /root/mongo/data:/data/db --name mymongo mongo 
</code></pre>
<h3 id="11-6-安装ElasticSearch"><a href="#11-6-安装ElasticSearch" class="headerlink" title="11.6 安装ElasticSearch"></a>11.6 安装ElasticSearch</h3><ul>
<li><code>注意:</code><strong>调高JVM线程数限制数量</strong></li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.5/docker.html" target="_blank" rel="noopener">官方ES docker安装手册</a></li>
<li><a href="https://www.elastic.co/cn/support/matrix#matrix_compatibility" target="_blank" rel="noopener">官方ES+Kibana版本匹配</a></li>
</ul>
<h4 id="11-6-0-拉取镜像试运行elasticsearch"><a href="#11-6-0-拉取镜像试运行elasticsearch" class="headerlink" title="11.6.0 拉取镜像试运行elasticsearch"></a>11.6.0 拉取镜像试运行elasticsearch</h4><pre><code class="markdown"># 1.dockerhub 拉取镜像
    docker pull elasticsearch:6.4.2
    docker pull elasticsearch:6.8.0
# 2.查看docker镜像
    docker images
# 3.运行docker镜像
    docker run -p 9200:9200 -p 9300:9300 elasticsearch:6.8.0
    参数：-e “discovery.type=single-node” 以单节点启动，在es中单节点就是集群模式，如果不加这个参数以默认的集群模式启动也是可以的
         --net somenetwork 指定docker网桥，使用中最好是指定网桥
         -p 9200 http 9300 tcp
</code></pre>
<ul>
<li>启动出现如下错误</li>
<li><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/image-20200602184321790.png" alt="image-20200602184321790"></li>
</ul>
<h4 id="11-6-1-预先配置"><a href="#11-6-1-预先配置" class="headerlink" title="11.6.1 预先配置"></a>11.6.1 预先配置</h4><pre><code class="markdown"># 1.在centos虚拟机中，修改配置sysctl.conf
    vim /etc/sysctl.conf
# 2.加入如下配置
    vm.max_map_count=262144 
# 3.启用配置
    sysctl -p
    注：这一步是为了防止启动容器时，报出如下错误：
    bootstrap checks failed max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144]
# 说明 max_map_count
    “This file contains the maximum number of memory map areas a process may have. Memory map areas are used as a side-effect of calling malloc, directly by mmap and mprotect, and also when loading shared libraries.

    While most applications need less than a thousand maps, certain programs, particularly malloc debuggers, may consume lots of them, e.g., up to one or two maps per allocation.

    The default value is 65536.”

    max_map_count文件包含限制一个进程可以拥有的VMA(虚拟内存区域)的数量。
    虚拟内存区域是一个连续的虚拟地址空间区域。在进程的生命周期中，每当程序尝试在内存中映射文件，链接到共享内存段，或者分配堆空间的时候，这些区域将被创建。
    调优这个值将限制进程可拥有VMA的数量。限制一个进程拥有VMA的总数可能导致应用程序出错，因为当进程达到了VMA上线但又只能释放少量的内存给其他的内核进程使用时，操作系统会抛出内存不足的错误。如果你的操作系统在NORMAL区域仅占用少量的内存，那么调低这个值可以帮助释放内存给内核用。

</code></pre>
<h4 id="11-6-2-启动EleasticSearch容器"><a href="#11-6-2-启动EleasticSearch容器" class="headerlink" title="11.6.2 启动EleasticSearch容器"></a>11.6.2 启动EleasticSearch容器</h4><pre><code class="markdown"># 0.复制容器中data目录到宿主机中
    docker cp 容器id:/usr/share/share/elasticsearch/data /root/es
# 1.运行ES容器 指定jvm内存大小并指定ik分词器位置
    docker run -d --name es -p 9200:9200 -p 9300:9300 \
    -e ES_JAVA_OPTS=&quot;-Xms128m -Xmx128m&quot; \
    -v /root/es/plugins:/usr/share/elasticsearch/plugins \
    -v /root/es/data:/usr/share/elasticsearch/data \
    elasticsearch:6.4.2

    docker run -d --name es -p 9200:9200 -p 9300:9300 \
    -v esplugins:/usr/share/elasticsearch/plugins \
    -v esdata:/usr/share/elasticsearch/data \
    -v esconfig:/usr/share/elasticsearch/config \
    elasticsearch:6.8.0
</code></pre>
<h4 id="11-6-3-安装IK分词器"><a href="#11-6-3-安装IK分词器" class="headerlink" title="11.6.3 安装IK分词器"></a>11.6.3 安装IK分词器</h4><pre><code class="markdown"># 1.下载对应版本的IK分词器
    wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.4.2/elasticsearch-analysis-ik-6.4.2.zip

    wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.8.0/elasticsearch-analysis-ik-6.8.0.zip

# 2.解压到plugins文件夹中
    yum install -y unzip
    cd /var/lib/docker/volumes/esplugins/_data
    mkdir ik
    cd ik
    cp /root/elasticsearch-analysis-ik-6.8.0.zip .
    unzip -d ik elasticsearch-analysis-ik-6.8.0.zip
    rm -rf elasticsearch-analysis-ik-6.8.0.zip

# 3.添加自定义扩展词和停用词（插件挂载目录夹解压ik的zip包下面有个config文件夹
    cd plugins/elasticsearch/config
    vim IKAnalyzer.cfg.xml
    &lt;properties&gt;
        &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;
        &lt;!--用户可以在这里配置自己的扩展字典 --&gt;
        &lt;entry key=&quot;ext_dict&quot;&gt;ext_dict.dic&lt;/entry&gt;
        &lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;
        &lt;entry key=&quot;ext_stopwords&quot;&gt;ext_stopwords.dic&lt;/entry&gt;
    &lt;/properties&gt;

# 4.在ik分词器目录下config目录中创建ext_dict.dic文件   编码一定要为UTF-8才能生效
    vim ext_dict.dic 加入扩展词即可
# 5. 在ik分词器目录下config目录中创建ext_stopword.dic文件 
    vim ext_stopwords.dic 加入停用词即可

# 6.重启容器生效
    docker restart 容器id
# 7.将此容器提交成为一个新的镜像
    docker commit -a=&quot;xiaochen666&quot; -m=&quot;es with IKAnalyzer&quot; 容器id xiaochen/elasticsearch:6.4.2
</code></pre>
<h4 id="11-6-4-安装Kibana"><a href="#11-6-4-安装Kibana" class="headerlink" title="11.6.4 安装Kibana"></a>11.6.4 安装Kibana</h4><pre><code class="markdown"># 1.下载kibana镜像到本地
    docker pull kibana:6.4.2
    docker pull kibana:6.8.0

# 2.启动kibana容器
    docker run -d --name kibana -e ELASTICSEARCH_URL=http://10.15.0.3:9200 -p 5601:5601 kibana:6.4.2
    docker run -d --name kibana -e ELASTICSEARCH_URL=http://10.15.0.3:9200 -p 5601:5601 kibana:6.8.0
# 3.映射配置
    docker run -d --name kibana -p 5601:5601 -v kibanaconf:/usr/share/kibana/config kibana:6.8.0
</code></pre>
<h3 id="11-7-安装Nexus3"><a href="#11-7-安装Nexus3" class="headerlink" title="11.7 安装Nexus3"></a>11.7 安装Nexus3</h3><pre><code class="markdown"># Nexus搭建
# 将离线镜像加载入docker
sudo docker load --input nexus.tar.gz

# 创建私库目录
mkdir -p /middleware/nexus-data 
chmod -R 777 /middleware/nexus-data

# 启动
sudo docker run --name finnexus \
-d --restart=unless-stopped \
-p 5000-5010:5000-5010 \
-p 8081:8081 \
-v /middleware/nexus-data:/nexus-data \
sonatype/nexus3
# 如果换端口
sudo docker run --restart=unless-stopped -d -p 4000-4010:5000-5010 -p 4081:8081 -v /app/nexus-data:/nexus-data --name nexus sonatype/nexus3

# -p 表示将服务器的端口与容器端口映射
# -v 表示将服务器的目录与容器的目录映射
# 其中neuxs映射的服务器路径要有权限
# 其中8081端口是对应nexus的管理界面的端口
# 5000-5010 表示5000到5010端口，后面创建私有仓库时端口必须在5000到5010之间

# 登录nexus控制台地址 ip:8081
# 如果换了端口 命令参考上面换过端口的命令
# 登录nexus控制台地址 ip:4081

# 查看默认登录密码
cd /app/nexus-data
cat admin.password
# 密码修改为你要的
# 具体设置单独开文章，这里就不多写了
</code></pre>
<h3 id="11-8-安装RabbitMQ"><a href="#11-8-安装RabbitMQ" class="headerlink" title="11.8 安装RabbitMQ"></a>11.8 安装RabbitMQ</h3><pre><code class="markdown"># 1.上传tar包

    rabbitmq.tar.gz

# 2.load tar包

docker load --input rabbitmq.tar.gz
  出现如下说明：
  2053661fb7d0: Loading layer  12.29kB/12.29kB
  5689db811598: Loading layer  40.96kB/40.96kB
  d2459d554acf: Loading layer  34.29MB/34.29MB
  fc486e98542a: Loading layer  11.13MB/11.13MB
  4bdd294e3b25: Loading layer  5.632kB/5.632kB
  b391c5160f19: Loading layer  2.048kB/2.048kB
  53a95db89e8a: Loading layer  1.536kB/1.536kB
  4db8bc9b75ab: Loading layer  15.36kB/15.36kB
  669bd8e5d693: Loading layer  3.072kB/3.072kB
  86e21faff3ee: Loading layer  37.92MB/37.92MB
  Loaded image: rabbitmq:3.7.8-management-alpine

# 3.创建宿主机映射目录

mkdir -p /middleware/rabbitmq/lib
mkdir -p /middleware/rabbitmq/log

# 4.docker run

docker run --name finrabbitmq \
-d --restart=unless-stopped \
-p 5672:5672 \
-p 15672:15672 \
-v /middleware/rabbitmq/lib:/var/lib/rabbitmq \
-v /middleware/rabbitmq/log:/var/log/rabbitmq \
rabbitmq:3.7.8-management-alpine

  -it 标准输入给容器并产生一个交互性shell
  -d 在后台运行
  --name 容器名
  -v 目录映射
  -p 端口映射

# 5.检查日志是否启动成功

  docker logs -t --tail=100 rabbitmq

# 6.登录ip:15672，默认用户名密码 guest/guest
</code></pre>
<h3 id="11-9-安装Minio"><a href="#11-9-安装Minio" class="headerlink" title="11.9 安装Minio"></a>11.9 安装Minio</h3><pre><code class="shell"># 存储目录：
mkdir -p /middleware/minio/data
mkdir -p /middleware/minio/config

# 启动命令：

docker run -p 9000:9000 --name finminio \
-d --restart=unless-stopped \
-e &quot;MINIO_ACCESS_KEY=fin&quot; \
-e &quot;MINIO_SECRET_KEY=eyQ3idRpVkNZ&quot; \
-v /middleware/minio/data:/data \
-v /middleware/minio/config:/root/.minio \
minio/minio server /data

# 控制台访问地址：
http://101.133.150.61:9100/minio/login
fin/eyQ3idRpVkNZ
</code></pre>
<h3 id="11-10-安装Nacos"><a href="#11-10-安装Nacos" class="headerlink" title="11.10 安装Nacos"></a>11.10 安装Nacos</h3><pre><code class="shell">docker load --input nacos.tar

mkdir -p /middleware/nacos/data
mkdir -p /middleware/nacos/logs

docker run \
--restart=unless-stopped \
--name finnacos \
--privileged=true \
-p 8848:8848 \
-e PREFER_HOST_MODE=ip \
-e MODE=standalone \
-e NACOS_SERVER_PORT=8848 \
-v /middleware/nacos/data:/home/nacos/data \
-v /middleware/nacos/logs:/home/nacos/logs \
-d nacos/nacos-server:1.4.0
</code></pre>
<h3 id="11-11-安装Rancher"><a href="#11-11-安装Rancher" class="headerlink" title="11.11 安装Rancher"></a>11.11 安装Rancher</h3><p>抽空加一下:D</p>
<h2 id="12-Dockerfile"><a href="#12-Dockerfile" class="headerlink" title="12.Dockerfile"></a>12.Dockerfile</h2><h3 id="12-1-什么是Dockerfile"><a href="#12-1-什么是Dockerfile" class="headerlink" title="12.1 什么是Dockerfile"></a>12.1 什么是Dockerfile</h3><p>Dockerfile可以认为是<strong>Docker镜像的描述文件，是由一系列命令和参数构成的脚本</strong>。主要作用是<strong>用来构建docker镜像的构建文件</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/image-20200404111908085.png" alt="image-20200404111908085"></p>
<ul>
<li><strong>通过架构图可以看出通过DockerFile可以直接构建镜像</strong></li>
</ul>
<h3 id="12-2-Dockerfile解析过程"><a href="#12-2-Dockerfile解析过程" class="headerlink" title="12.2 Dockerfile解析过程"></a>12.2 Dockerfile解析过程</h3><p><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/image-20200603181253804.png" alt="image-20200603181253804"></p>
<h3 id="12-3-Dockerfile的保留命令"><a href="#12-3-Dockerfile的保留命令" class="headerlink" title="12.3 Dockerfile的保留命令"></a>12.3 Dockerfile的保留命令</h3><p><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">官方说明</a></p>
<table>
<thead>
<tr>
<th>保留字</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>FROM</strong></td>
<td><strong>当前镜像是基于哪个镜像的</strong> <code>第一个指令必须是FROM</code></td>
</tr>
<tr>
<td>MAINTAINER</td>
<td>镜像维护者的姓名和邮箱地址</td>
</tr>
<tr>
<td><strong>RUN</strong></td>
<td><strong>构建镜像时需要运行的指令</strong></td>
</tr>
<tr>
<td><strong>EXPOSE</strong></td>
<td><strong>当前容器对外暴露出的端口号</strong></td>
</tr>
<tr>
<td><strong>WORKDIR</strong></td>
<td><strong>指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</strong></td>
</tr>
<tr>
<td><strong>ENV</strong></td>
<td><strong>用来在构建镜像过程中设置环境变量</strong></td>
</tr>
<tr>
<td><strong>ADD</strong></td>
<td><strong>将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包</strong></td>
</tr>
<tr>
<td><strong>COPY</strong></td>
<td><strong>类似于ADD，拷贝文件和目录到镜像中<br>将从构建上下文目录中&lt;原路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</strong></td>
</tr>
<tr>
<td><strong>VOLUME</strong></td>
<td><strong>容器数据卷，用于数据保存和持久化工作</strong></td>
</tr>
<tr>
<td><strong>CMD</strong></td>
<td><strong>指定一个容器启动时要运行的命令<br>Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换</strong></td>
</tr>
<tr>
<td><strong>ENTRYPOINT</strong></td>
<td><strong>指定一个容器启动时要运行的命令<br>ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及其参数</strong></td>
</tr>
</tbody>
</table>
<h4 id="12-3-1-FROM-命令"><a href="#12-3-1-FROM-命令" class="headerlink" title="12.3.1 FROM 命令"></a>12.3.1 FROM 命令</h4><ul>
<li><p>基于那个镜像进行构建新的镜像,在构建时会自动从docker hub拉取base镜像 必须作为Dockerfile的第一个指令出现</p>
</li>
<li><p>语法:</p>
<pre><code class="dockerfile">FROM  &lt;image&gt;
FROM  &lt;image&gt;[:&lt;tag&gt;]     使用版本不写为latest
FROM  &lt;image&gt;[@&lt;digest&gt;]  使用摘要
</code></pre>
</li>
</ul>
<h4 id="12-3-2-MAINTAINER-命令"><a href="#12-3-2-MAINTAINER-命令" class="headerlink" title="12.3.2 MAINTAINER  命令"></a>12.3.2 MAINTAINER  命令</h4><ul>
<li><p>镜像维护者的姓名和邮箱地址[废弃]</p>
</li>
<li><p>语法:</p>
<pre><code class="dockerfile">MAINTAINER &lt;name&gt;
</code></pre>
</li>
</ul>
<h4 id="12-3-3-RUN-命令"><a href="#12-3-3-RUN-命令" class="headerlink" title="12.3.3 RUN 命令"></a>12.3.3 RUN 命令</h4><ul>
<li><p>RUN指令将在当前映像之上的新层中执行任何命令并提交结果。生成的提交映像将用于Dockerfile中的下一步</p>
</li>
<li><p>语法:</p>
<pre><code class="dockerfile">RUN &lt;command&gt; (shell form, the command is run in a shell, which by default is /bin/sh -c on Linux or cmd /S /C on Windows)
RUN echo hello

RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (exec form)
RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]
</code></pre>
</li>
</ul>
<h4 id="12-3-4-EXPOSE-命令"><a href="#12-3-4-EXPOSE-命令" class="headerlink" title="12.3.4 EXPOSE 命令"></a>12.3.4 EXPOSE 命令</h4><ul>
<li><p>用来指定构建的镜像在运行为容器时对外暴露的端口</p>
</li>
<li><p>语法:</p>
<pre><code class="dockerfile">EXPOSE 80/tcp  如果没有显示指定则默认暴露都是tcp
EXPOSE 80/udp
</code></pre>
</li>
</ul>
<h4 id="12-3-5-CMD-命令"><a href="#12-3-5-CMD-命令" class="headerlink" title="12.3.5 CMD 命令"></a>12.3.5 CMD 命令</h4><ul>
<li><p>用来为启动的容器指定执行的命令,在Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</p>
</li>
<li><p>注意: <strong>Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</strong></p>
</li>
<li><p>语法:</p>
<pre><code class="dockerfile">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec form, this is the preferred form)
CMD [&quot;param1&quot;,&quot;param2&quot;] (as default parameters to ENTRYPOINT)
CMD command param1 param2 (shell form)
</code></pre>
</li>
</ul>
<h4 id="12-3-6-WORKDIR-命令"><a href="#12-3-6-WORKDIR-命令" class="headerlink" title="12.3.6 WORKDIR 命令"></a>12.3.6 WORKDIR 命令</h4><ul>
<li><p>用来为Dockerfile中的任何RUN、CMD、ENTRYPOINT、COPY和ADD指令设置工作目录。如果WORKDIR不存在，即使它没有在任何后续Dockerfile指令中使用，它也将被创建。</p>
</li>
<li><p>语法:</p>
<pre><code class="dockerfile">WORKDIR /path/to/workdir

WORKDIR /a
WORKDIR b
WORKDIR c
`注意:WORKDIR指令可以在Dockerfile中多次使用。如果提供了相对路径，则该路径将与先前WORKDIR指令的路径相对`
</code></pre>
</li>
</ul>
<h4 id="12-3-7-ENV-命令"><a href="#12-3-7-ENV-命令" class="headerlink" title="12.3.7 ENV 命令"></a>12.3.7 ENV 命令</h4><ul>
<li><p>用来为构建镜像设置环境变量。这个值将出现在构建阶段中所有后续指令的环境中。</p>
</li>
<li><p>语法：</p>
<pre><code class="dockerfile">ENV &lt;key&gt; &lt;value&gt;
ENV &lt;key&gt;=&lt;value&gt; ...
</code></pre>
</li>
</ul>
<h4 id="12-3-8-ADD-命令"><a href="#12-3-8-ADD-命令" class="headerlink" title="12.3.8 ADD 命令"></a>12.3.8 ADD 命令</h4><ul>
<li><p>用来从context上下文复制新文件、目录或远程文件url，并将它们添加到位于指定路径的映像文件系统中。</p>
</li>
<li><p>语法:</p>
<pre><code class="dockerfile">ADD hom* /mydir/       通配符添加多个文件
ADD hom?.txt /mydir/   通配符添加
ADD test.txt relativeDir/  可以指定相对路径
ADD test.txt /absoluteDir/ 也可以指定绝对路径
ADD url 
</code></pre>
</li>
</ul>
<h4 id="12-3-9-COPY-命令"><a href="#12-3-9-COPY-命令" class="headerlink" title="12.3.9 COPY 命令"></a>12.3.9 COPY 命令</h4><ul>
<li><p>用来将context目录中指定文件复制到镜像的指定目录中</p>
</li>
<li><p>语法:</p>
<pre><code class="dockerfile">COPY src dest
COPY [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]
</code></pre>
</li>
</ul>
<h4 id="12-3-10-VOLUME-命令"><a href="#12-3-10-VOLUME-命令" class="headerlink" title="12.3.10 VOLUME 命令"></a>12.3.10 VOLUME 命令</h4><ul>
<li><p>用来定义容器运行时可以挂在到宿主机的目录</p>
</li>
<li><p>语法:</p>
<pre><code class="dockerfile">VOLUME [&quot;/data&quot;]
</code></pre>
</li>
</ul>
<h4 id="12-3-11-ENTRYPOINT命令"><a href="#12-3-11-ENTRYPOINT命令" class="headerlink" title="12.3.11 ENTRYPOINT命令"></a>12.3.11 ENTRYPOINT命令</h4><ul>
<li><p>用来指定容器启动时执行命令和CMD类似</p>
</li>
<li><p>语法:</p>
<pre><code class="dockerfile">  [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]
ENTRYPOINT command param1 param2
</code></pre>
<p>ENTRYPOINT指令，往往用于设置容器启动后的<strong>第一个命令</strong>，这对一个容器来说往往是固定的。<br>CMD指令，往往用于设置容器启动的第一个命令的<strong>默认参数</strong>，这对一个容器来说可以是变化的。</p>
</li>
</ul>
<h3 id="12-4-Dockerfile举例（方便理解）"><a href="#12-4-Dockerfile举例（方便理解）" class="headerlink" title="12.4 Dockerfile举例（方便理解）"></a>12.4 Dockerfile举例（方便理解）</h3><pre><code class="shell"># 举例中你可能用到的命令
touch bb.txt

echo &quot;666&quot; &gt;&gt; bb.txt

docker build -t mycentos7:1 .
</code></pre>
<pre><code class="dockerfile">FROM centos:7
# 我要基于原来的镜像往里安装里没有的指令的并创建新的进镜像 这里装了vim
#RUN yum intall -y vim
RUN [&quot;yum&quot;,&quot;install&quot;,&quot;-y&quot;,&quot;vim&quot;]
# EXPOSE 服务 docker run 的 -p 命令 只有expose之后才能-p生效
EXPOSE 5672
EXPOSE 15672
# WORKDIR 指定的工作目录 目录不存在会给你创建 意思是你docker run之后 进入容器的目录
# 下面的两个WORKDIR设置之后运行了容器 你进入之后pwd 显示的目录就是/data/a
WORKDIR /data
WORKDIR a
# dockerfile目录下还有个aa.txt 把这个东西拷贝到新创建的容器里
COPY aa.txt /data/a
# ADD 和 COPY差不多 只不过他能自动下载（放url）还能解压
ADD bb.txt /data/b
# 这样使用 ADD 会下载gz包 这时候不解压 直接丢进/data/b
# ADD https://download.redis.io/releases/redis-6.2.4.tar.gz /data/b

# 这样使用 ADD 会将本地gz包 解压缩到新建容器的/data/b
# ADD redis-6.2.4.tar.gz /data/b
# 如果这时候你在 run mv 就会把解压文件 丢进去redis文件夹
# RUN mv redis-6.2.4 redis
# 如果你再设置工作目录 这时候进入运行的新容器就会进入 /data/b/redis 
# WORKDIR redis

# VOLUME 服务 -v 只有写了 -v 才能允许挂载（这个概念可能不对 有时间验证验证）
VOLUME /data/b

# ENV 设置环境变量 很好理解 设置之后后面都能用
ENV BASE_DIR /data/b
ADD bb.txt $BASE_DIR
VOLUME $BASE_DIR/test

# 指定容器运行的命令 运行了 ls 会在docker的宿主机输出 ls输出的内容
# ENTRYPOINT 可以写多个 覆盖需要加上 --entrypoint = ls 
# docker run --entrypoint=ls mycentos7:18 /data/a
#ENTRYPOINT ls $BASE_DIR/test
# CMD 可以执行多个 可以被 docker run 之后的命令覆盖掉
# docker rum mycentos7:18 ls /data/b
#CMD ls /data/b/

#一般ENTRYPOINT和CMD连用 CMD后面作为参数 传给ENTRYPOINT
# 如果 docker run mycentos7:19 则只输出 data下目录
# 如果 docker run mycentos7:19 
# 这种shell 格式不生效 需要使用 json数组形式
# ENTRYPOINT ls /data
# CMD /data/b

# 以下build完成之后会输出 ls /data 也会输出 ls /data/b
ENTRYPOINT [&quot;ls&quot;,&quot;/data&quot;]
CMD [&quot;/data/b&quot;]

# 总结 ENTRYPOINT 写参数 CMD 写参数

</code></pre>
<h3 id="12-5-IDEA的Dockerfile插件"><a href="#12-5-IDEA的Dockerfile插件" class="headerlink" title="12.5 IDEA的Dockerfile插件"></a>12.5 IDEA的Dockerfile插件</h3><p>我的idea版本已经内置了</p>
<p><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/image-20210616171725758.png" alt="image-20210616171725758"></p>
<p>IDEA sftp</p>
<p><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/image-20210616172705734.png" alt="image-20210616172705734"></p>
<h3 id="12-6-Dockerfile构建springboot项目部署"><a href="#12-6-Dockerfile构建springboot项目部署" class="headerlink" title="12.6 Dockerfile构建springboot项目部署"></a>12.6 Dockerfile构建springboot项目部署</h3><h4 id="12-6-1-准备springboot可运行项目"><a href="#12-6-1-准备springboot可运行项目" class="headerlink" title="12.6.1 准备springboot可运行项目"></a>12.6.1 准备springboot可运行项目</h4><p><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/image-20200605172151266.png" alt="image-20200605172151266"></p>
<h4 id="12-6-2-将可运行项目放入linux虚拟机中"><a href="#12-6-2-将可运行项目放入linux虚拟机中" class="headerlink" title="12.6.2 将可运行项目放入linux虚拟机中"></a>12.6.2 将可运行项目放入linux虚拟机中</h4><p><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/image-20200605172340380.png" alt="image-20200605172340380"></p>
<h4 id="12-6-3-编写Dockerfile"><a href="#12-6-3-编写Dockerfile" class="headerlink" title="12.6.3 编写Dockerfile"></a>12.6.3 编写Dockerfile</h4><pre><code class="dockerfile">FROM openjdk:8
WORKDIR /ems
ADD ems.jar /ems
EXPOSE 8989
ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;]
CMD [&quot;ems.jar&quot;]
</code></pre>
<h4 id="12-6-4-构建镜像"><a href="#12-6-4-构建镜像" class="headerlink" title="12.6.4 构建镜像"></a>12.6.4 构建镜像</h4><pre><code class="shell">[root@localhost ems]# docker build -t ems .
</code></pre>
<h4 id="12-6-5-运行镜像"><a href="#12-6-5-运行镜像" class="headerlink" title="12.6.5 运行镜像"></a>12.6.5 运行镜像</h4><pre><code class="shell">[root@localhost ems]# docker run -p 8989:8989 ems
</code></pre>
<h4 id="12-6-6-访问项目"><a href="#12-6-6-访问项目" class="headerlink" title="12.6.6 访问项目"></a>12.6.6 访问项目</h4><pre><code class="http">http://10.15.0.8:8989/ems/login.html
</code></pre>
<h2 id="13-Docker-Compose"><a href="#13-Docker-Compose" class="headerlink" title="13.Docker Compose"></a>13.Docker Compose</h2><p>相关参考文档：</p>
<ul>
<li><a href="https://vuepress.mirror.docker-practice.com/compose/introduction/" target="_blank" rel="noopener">Compose 简介 | Docker 从入门到实践 (docker-practice.com)</a></li>
<li><a href="https://vuepress.mirror.docker-practice.com/compose/compose_file/" target="_blank" rel="noopener">Compose 模板文件 | Docker 从入门到实践 (docker-practice.com)</a></li>
<li><a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener">Compose file | Docker Documentation（docker引擎兼容版本）</a></li>
</ul>
<h3 id="13-1-简介"><a href="#13-1-简介" class="headerlink" title="13.1 简介"></a>13.1 简介</h3><p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 <code>OpenStack</code> 中的 <code>Heat</code> 十分类似。</p>
<p>其代码目前在 <a href="https://github.com/docker/compose" target="_blank" rel="noopener">https://github.com/docker/compose</a> 上开源。</p>
<p><code>Compose</code> 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。</p>
<p>通过第一部分中的介绍，我们知道使用一个 <code>Dockerfile</code> 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p>
<p><code>Compose</code> 恰好满足了这样的需求。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>
<p><code>Compose</code> 中有两个重要的概念：</p>
<ul>
<li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li>
<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li>
</ul>
<p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p>
<p><code>Compose</code> 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 <code>Compose</code> 来进行编排管理。</p>
<h3 id="13-2-安装与卸载"><a href="#13-2-安装与卸载" class="headerlink" title="13.2 安装与卸载"></a>13.2 安装与卸载</h3><h4 id="13-2-1-linux"><a href="#13-2-1-linux" class="headerlink" title="13.2.1 linux"></a>13.2.1 linux</h4><ul>
<li>在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。例如，在 Linux 64 位系统上直接下载对应的二进制包。</li>
</ul>
<pre><code class="bash">$ sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose
$ sudo chmod +x /usr/local/bin/docker-compose
</code></pre>
<h4 id="13-2-2-macos、window"><a href="#13-2-2-macos、window" class="headerlink" title="13.2.2 macos、window"></a>13.2.2 macos、window</h4><ul>
<li>Compose 可以通过 Python 的包管理工具 pip 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。<code>Docker Desktop for Mac/Windows 自带 docker-compose 二进制文件，安装 Docker 之后可以直接使用</code>。</li>
</ul>
<h4 id="13-2-3-bash命令补全"><a href="#13-2-3-bash命令补全" class="headerlink" title="13.2.3 bash命令补全"></a>13.2.3 bash命令补全</h4><pre><code class="shell">$ curl -L https://raw.githubusercontent.com/docker/compose/1.25.5/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose
</code></pre>
<h4 id="13-2-4-离线"><a href="#13-2-4-离线" class="headerlink" title="13.2.4 离线"></a>13.2.4 离线</h4><p>就是下载二进制文件，改名，丢进local/bin</p>
<p><a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">官方</a>网站里找你需要的版本</p>
<p><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/image-20210616181426416.png" alt="image-20210616181426416"></p>
<pre><code class="shell">mv docker-compose-Linux-x86_64 docker-compose
mv docker-compose /usr/local/bin
chmod +x /usr/local/bin/docker-compose 
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/image-20210616184306066.png" alt="image-20210616184306066"></p>
<h4 id="13-2-5-卸载"><a href="#13-2-5-卸载" class="headerlink" title="13.2.5 卸载"></a>13.2.5 卸载</h4><ul>
<li>如果是二进制包方式安装的，删除二进制文件即可。</li>
</ul>
<pre><code class="shell">$ sudo rm /usr/local/bin/docker-compose
</code></pre>
<h4 id="13-2-6-测试安装成功"><a href="#13-2-6-测试安装成功" class="headerlink" title="13.2.6 测试安装成功"></a>13.2.6 测试安装成功</h4><pre><code class="shell">$ docker-compose --version
 docker-compose version 1.25.5, build 4667896b
</code></pre>
<h3 id="13-3-docker-compose使用"><a href="#13-3-docker-compose使用" class="headerlink" title="13.3 docker compose使用"></a>13.3 docker compose使用</h3><h4 id="13-3-1-相关概念"><a href="#13-3-1-相关概念" class="headerlink" title="13.3.1 相关概念"></a>13.3.1 相关概念</h4><p>首先介绍几个术语。</p>
<ul>
<li>服务 (<code>service</code>)：一个应用容器，实际上可以运行多个相同镜像的实例。</li>
<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元。∂一个项目可以由多个服务（容器）关联而成，<code>Compose</code> 面向项目进行管理。</li>
</ul>
<h4 id="13-3-2-场景"><a href="#13-3-2-场景" class="headerlink" title="13.3.2 场景"></a>13.3.2 场景</h4><p>最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。</p>
<ul>
<li>springboot应用</li>
<li>mysql服务</li>
<li>redis服务</li>
<li>elasticsearch服务</li>
<li>…….</li>
</ul>
<h4 id="13-3-3-docker-compose模板"><a href="#13-3-3-docker-compose模板" class="headerlink" title="13.3.3 docker-compose模板"></a>13.3.3 docker-compose模板</h4><p><a href="https://docker_practice.gitee.io/zh-cn/compose/compose_file.html" target="_blank" rel="noopener">参考文档</a></p>
<pre><code class="yml">version: &quot;3.0&quot;
services:

    demo:
      build:
        context: demo
        dockerfile: Dockerfile
      container_name: demo
      ports:
        - &quot;8081:8081&quot;
      networks:
        - hello
      depends_on:
        - tomcat01

  mysqldb:
    image: mysql:5.7.19
    container_name: mysql
    ports:
      - &quot;3306:3306&quot;
    volumes:
      - /root/mysql/conf:/etc/mysql/conf.d
      - /root/mysql/logs:/logs
      - /root/mysql/data:/var/lib/mysql
    environment:
      MYSQL_ROOT_PASSWORD: root
    networks:
      - ems
    depends_on:
      - redis

  redis:
    image: redis:4.0.14
    container_name: redis
    ports:
      - &quot;6379:6379&quot;
    networks:
      - ems
    volumes:
      - /root/redis/data:/data
    command: redis-server

networks:
  ems:
</code></pre>
<pre><code class="markdown">- 练习
</code></pre>
<pre><code class="yaml">version: &quot;3.2&quot;

services:
  tomcat01: #服务名称
    container_name: tomcat01 # 相当于run 的 --name
    image: tomcat:8.0-jre8 #使用哪个镜像  相当于run image
    ports:  #用来完成host与容器的端口映射关系  相当于run -p
      - &quot;8080:8080&quot;
    volumes: #完成宿主机与容器中目录数据卷共享  相当于run -v
      #- /root/apps:/usr/local/tomcat/webapps #使用自定义路径映射
      - tomcatwebapps01:/usr/local/tomcat/webapps
    networks: #代表当前服务使用哪个网络桥     相当于run --network
      - hello
    depends_on: #代表这个容器必须依赖哪个容器之后才能启动 这个依赖启动并不是说等
        - tomcat02 #这里书写的是服务名
        - redis
        - mysql
    healthcheck: #心跳检测
      test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;] #和docker内核通信
      interval: 1m30s
      timeout: 10s
      retries: 3

  tomcat02: #服务名称
    container_name: tomcat02
    image: tomcat:8.0-jre8 #使用哪个镜像
    ports:  #用来完成host与容器的端口映射关系
      - &quot;8081:8080&quot;
    volumes: #完成宿主机与容器中目录数据卷共享
      #- /root/apps:/usr/local/tomcat/webapps #使用自定义路径映射
      - tomcatwebapps02:/usr/local/tomcat/webapps
    networks: #代表当前服务使用哪个网络桥
      - hello
    #sysctls: #用来修改容器中系统内部参数 并不是必须的有些服务启动受容器内操作系统参数限制可能会无法启动
    # - net.core.somaxconn=1024
    # - net.ipv4.tcp_syncookies=0
    #ulimits: #用来修改容器中系统内部进程数限制 可以根据当前运行服务要求进行更改
    #  nproc: 65535
    #  nofile:
    #    soft: 20000
    #    hard: 40000

  mysql:
    image: mysql:5.7.32
    container_name: mysql
    ports:
      - &quot;3307:3306&quot;
    volumes:
      - mysqldata:/var/lib/mysql
      - mysqlconf:/etc/mysql
    #environment:
    #  - MYSQL_ROOT_PASSWORD=root
    env_file: #用来将environment配置放入指定的配置文件中
        - mysql.env #compose的当前路径
    networks:
      - hello

  redis:
    image: redis:5.0.10
    container_name: redis
    ports:
      - &quot;6379:6379&quot;
    volumes:
      - redisdata:/data
    networks:
      - hello
    command: &quot;redis-server --appendonly yes&quot; #run 镜像之后用来覆盖容器内容默认命令




volumes:  #声明上面服务所使用的自动创建的卷名
  tomcatwebapps01: #声明指令的卷名  compose自动创建该卷名但是会在之前加入项目名
    external:    #使用自定义卷名
      false       #true确定使用指定卷名  注意:一旦使用外部自定义卷名启动服务之前必须手动创建
  tomcatwebapps02:
  mysqldata:
  mysqlconf:
  redisdata:

networks: #定义服务用到桥
  hello: #定义上面的服务用到的网桥名称 默认创建就是 bridge
    external:
      true   #使用外部指定网桥  注意:网桥必须存在
</code></pre>
<h4 id="13-3-4-通过docker-compose运行一组容器"><a href="#13-3-4-通过docker-compose运行一组容器" class="headerlink" title="13.3.4 通过docker-compose运行一组容器"></a>13.3.4 通过docker-compose运行一组容器</h4><p><a href="https://docker_practice.gitee.io/zh-cn/compose/commands.html" target="_blank" rel="noopener">参考文档</a></p>
<pre><code class="bash">[root@centos ~]# docker-compose up                                //前台启动一组服务
[root@centos ~]# docker-compose up -d                             //后台启动一组服务
</code></pre>
<h3 id="13-4-docker-compose-模板文件"><a href="#13-4-docker-compose-模板文件" class="headerlink" title="13.4 docker-compose 模板文件"></a>13.4 docker-compose 模板文件</h3><p>模板文件是使用 <code>Compose</code> 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 <code>docker run</code> 相关参数的含义都是类似的。</p>
<p>默认的模板文件名称为 <code>docker-compose.yml</code>，格式为 YAML 格式。</p>
<pre><code class="yaml">version: &quot;3&quot; #docker-compose的版本

services:
  webapp:
    image: examples/web
    ports:
      - &quot;80:80&quot;
    volumes:
      - &quot;/data&quot;
</code></pre>
<p>注意每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像。</p>
<p>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：<code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等) 将会自动被获取，无需在 <code>docker-compose.yml</code> 中重复设置。</p>
<p>下面分别介绍各个指令的用法。（下面的命令并不是全部，详细可以去查看中文文档，在13节开头已经给出相关网址）</p>
<h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 <code>Compose</code> 将会利用它自动构建这个镜像，然后使用这个镜像。</p>
<pre><code class="yaml">version: &#39;3&#39;
services:

  webapp:
    build: ./dir
</code></pre>
<p>你也可以使用 <code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径。</p>
<p>使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名。</p>
<p>使用 <code>arg</code> 指令指定构建镜像时的变量。</p>
<pre><code class="yaml">version: &#39;3&#39;
services:

  webapp:
    build:
      context: ./dir #相对路径 相对于docker-compose.yml
      dockerfile: Dockerfile-alternate
      args:
        buildno: 1
</code></pre>
<h4 id="command"><a href="#command" class="headerlink" title="command"></a>command</h4><p>覆盖容器启动后默认执行的命令。</p>
<pre><code class="yaml">command: echo &quot;hello world&quot;
</code></pre>
<h4 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h4><p>指定容器名称。默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式。</p>
<pre><code class="yaml">container_name: docker-web-container
</code></pre>
<blockquote>
<p>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</p>
</blockquote>
<h4 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h4><p>解决容器的依赖、启动先后的问题。以下例子中会先启动 <code>redis</code> <code>db</code> 再启动 <code>web</code></p>
<pre><code class="yaml">version: &#39;3&#39;

services:
  web:
    build: .
    depends_on:
      - db
      - redis

  redis:
    image: redis

  db:
    image: postgres
</code></pre>
<blockquote>
<p>注意：<code>web</code> 服务不会等待 <code>redis</code> <code>db</code> 「完全启动」之后才启动。</p>
</blockquote>
<h4 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h4><p>从文件中获取环境变量，可以为单独的文件路径或列表。</p>
<p>如果通过 <code>docker-compose -f FILE</code> 方式来指定 Compose 模板文件，则 <code>env_file</code> 中变量的路径会基于模板文件路径。</p>
<p>如果有变量名称与 <code>environment</code> 指令冲突，则按照惯例，以后者为准。</p>
<pre><code class="bash">env_file: .env

env_file:
  - ./common.env
  - ./apps/web.env
  - /opt/secrets.env
</code></pre>
<p>环境变量文件中每一行必须符合格式，支持 <code>#</code> 开头的注释行。</p>
<pre><code class="bash"># common.env: Set development environment
PROG_ENV=development
</code></pre>
<h4 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h4><p>设置环境变量。你可以使用数组或字典两种格式。</p>
<p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p>
<pre><code class="yaml">environment:
  RACK_ENV: development
  SESSION_SECRET:

environment:
  - RACK_ENV=development
  - SESSION_SECRET
</code></pre>
<p>如果变量名称或者值中用到 <code>true|false，yes|no</code> 等表达 <a href="https://yaml.org/type/bool.html" target="_blank" rel="noopener">布尔</a> 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p>
<pre><code class="bash">y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF
</code></pre>
<h4 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a>healthcheck</h4><p>通过命令检查容器是否健康运行。</p>
<pre><code class="yaml">healthcheck:
  test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;]
  interval: 1m30s
  timeout: 10s
  retries: 3
</code></pre>
<h4 id="image"><a href="#image" class="headerlink" title="image"></a>image</h4><p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，<code>Compose</code> 将会尝试拉取这个镜像。</p>
<pre><code class="yaml">image: ubuntu
image: orchardup/postgresql
image: a4bc65fd
</code></pre>
<h4 id="networks"><a href="#networks" class="headerlink" title="networks"></a>networks</h4><p>配置容器连接的网络。</p>
<pre><code class="yaml">version: &quot;3&quot;
services:

  some-service:
    networks:
     - some-network
     - other-network

networks:
  some-network:
  other-network:
</code></pre>
<h4 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h4><p>暴露端口信息。</p>
<p>使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p>
<pre><code class="yaml">ports:
 - &quot;3000&quot;
 - &quot;8000:8000&quot;
 - &quot;49100:22&quot;
 - &quot;127.0.0.1:8001:8001&quot;
</code></pre>
<p><em>注意：当使用 <code>HOST:CONTAINER</code> 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 <code>YAML</code> 会自动解析 <code>xx:yy</code> 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</em></p>
<h4 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a>sysctls</h4><p>配置容器内核参数。</p>
<pre><code class="yaml">sysctls:
  net.core.somaxconn: 1024
  net.ipv4.tcp_syncookies: 0

sysctls:
  - net.core.somaxconn=1024
  - net.ipv4.tcp_syncookies=0
</code></pre>
<h4 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a>ulimits</h4><p>指定容器的 ulimits 限制值。</p>
<p>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p>
<pre><code class="yaml">  ulimits:
    nproc: 65535
    nofile:
      soft: 20000
      hard: 40000
</code></pre>
<h4 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h4><p>数据卷所挂载路径设置。可以设置为宿主机路径(<code>HOST:CONTAINER</code>)或者数据卷名称(<code>VOLUME:CONTAINER</code>)，并且可以设置访问模式 （<code>HOST:CONTAINER:ro</code>）。</p>
<p>该指令中路径支持相对路径。</p>
<pre><code class="yaml">volumes:
 - /var/lib/mysql:/var/lib/mysql
 - cache/:/tmp/cache
 - ~/configs:/etc/configs/:ro
</code></pre>
<p>如果路径为数据卷名称，必须在文件中配置数据卷。</p>
<pre><code class="yaml">version: &quot;3&quot;

services:
  my_src:
    image: mysql:8.0
    volumes:
      - mysql_data:/var/lib/mysql

volumes:
  mysql_data:
</code></pre>
<h3 id="13-5-docker-compose-常用命令"><a href="#13-5-docker-compose-常用命令" class="headerlink" title="13.5 docker-compose 常用命令"></a>13.5 docker-compose 常用命令</h3><h4 id="13-5-1-命令对象与格式"><a href="#13-5-1-命令对象与格式" class="headerlink" title="13.5.1 命令对象与格式"></a>13.5.1 命令对象与格式</h4><p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p>
<p>执行 <code>docker-compose [COMMAND] --help</code> 或者 <code>docker-compose help [COMMAND]</code> 可以查看具体某个命令的使用格式。</p>
<p><code>docker-compose</code> 命令的基本的使用格式是</p>
<pre><code class="bash">docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]

docker-compose -f your-compose.yml -p your-project up
</code></pre>
<h4 id="13-5-2-命令选项"><a href="#13-5-2-命令选项" class="headerlink" title="13.5.2 命令选项"></a>13.5.2 命令选项</h4><ul>
<li><code>-f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</li>
<li><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</li>
<li><code>--x-networking</code> 使用 Docker 的可拔插网络后端特性</li>
<li><code>--x-network-driver DRIVER</code> 指定网络后端的驱动，默认为 <code>bridge</code></li>
<li><code>--verbose</code> 输出更多调试信息。</li>
<li><code>-v, --version</code> 打印版本并退出。</li>
</ul>
<h4 id="13-5-3-命令使用说明"><a href="#13-5-3-命令使用说明" class="headerlink" title="13.5.3 命令使用说明"></a>13.5.3 命令使用说明</h4><h5 id="up"><a href="#up" class="headerlink" title="up"></a>up</h5><p>格式为 <code>docker-compose up [options] [SERVICE...]</code>。</p>
<ul>
<li><p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p>
</li>
<li><p>链接的服务都将会被自动启动，除非已经处于运行状态。</p>
</li>
<li><p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p>
</li>
<li><p>默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p>
</li>
<li><p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p>
</li>
<li><p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p>
</li>
<li><p>默认情况，如果服务容器已经存在，<code>docker-compose up</code> 将会尝试停止容器，然后重新创建（保持使用 <code>volumes-from</code> 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容</p>
</li>
</ul>
<hr>
<h5 id="down"><a href="#down" class="headerlink" title="down"></a>down</h5><ul>
<li>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</li>
</ul>
<hr>
<h5 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h5><ul>
<li>进入指定的容器。</li>
<li>docker-compose exec redis（docker-compose.yml中声明的服务id）bash</li>
</ul>
<hr>
<h5 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h5><p>格式为 <code>docker-compose ps [options] [SERVICE...]</code>。</p>
<p>列出项目中目前的所有容器。</p>
<p>选项：</p>
<ul>
<li><code>-q</code> 只打印容器的 ID 信息。</li>
</ul>
<hr>
<h5 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h5><p>格式为 <code>docker-compose restart [options] [SERVICE...]</code>。</p>
<p>重启项目中的服务。</p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认为 10 秒）。</li>
</ul>
<hr>
<h5 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h5><p>格式为 <code>docker-compose rm [options] [SERVICE...]</code>。</p>
<p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。</p>
<p>选项：</p>
<ul>
<li><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</li>
<li><code>-v</code> 删除容器所挂载的数据卷。</li>
</ul>
<hr>
<h5 id="start"><a href="#start" class="headerlink" title="start"></a>start</h5><p>格式为 <code>docker-compose start [SERVICE...]</code>。</p>
<p>启动已经存在的服务容器。</p>
<hr>
<h5 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h5><p>格式为 <code>docker-compose stop [options] [SERVICE...]</code>。</p>
<p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker-compose start</code> 可以再次启动这些容器。</p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>
</ul>
<hr>
<h5 id="top"><a href="#top" class="headerlink" title="top"></a>top</h5><p>查看各个服务容器内运行的进程。</p>
<hr>
<h5 id="pause"><a href="#pause" class="headerlink" title="pause"></a>pause</h5><p>格式为 <code>docker-compose pause [SERVICE...]</code>。</p>
<p>暂停服务。</p>
<hr>
<h5 id="unpause"><a href="#unpause" class="headerlink" title="unpause"></a>unpause</h5><p>格式为 <code>docker-compose unpause [SERVICE...]</code>。</p>
<p>恢复处于暂停状态中的服务。</p>
<hr>
<h5 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h5><p>格式为 <code>docker-compose logs [SERVICE...]</code>。</p>
<p>查看日志。</p>
<h2 id="14-Docker可视化工具"><a href="#14-Docker可视化工具" class="headerlink" title="14.Docker可视化工具"></a>14.Docker可视化工具</h2><h3 id="14-1-安装Portainer"><a href="#14-1-安装Portainer" class="headerlink" title="14.1 安装Portainer"></a>14.1 安装Portainer</h3><p>官方安装说明：<a href="http://www.yunweipai.com/go?_=8fe4813824aHR0cHM6Ly93d3cucG9ydGFpbmVyLmlvL2luc3RhbGxhdGlvbi8=" target="_blank" rel="noopener">https://www.portainer.io/installation/</a></p>
<pre><code class="shell">[root@ubuntu1804 ~]#docker pull  portainer/portainer

[root@ubuntu1804 ~]#docker volume create portainer_data
portainer_data
[root@ubuntu1804 ~]#docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer
20db26b67b791648c2ef6aee444a5226a9c897ebcf0160050e722dbf4a4906e3
[root@ubuntu1804 ~]#docker ps 
CONTAINER ID        IMAGE                 COMMAND             CREATED             STATUS              PORTS                                            NAMES
20db26b67b79        portainer/portainer   &quot;/portainer&quot;        5 seconds ago       Up 4 seconds        0.0.0.0:8000-&gt;8000/tcp, 0.0.0.0:9000-&gt;9000/tcp   portainer
</code></pre>
<p>docker-compose</p>
<pre><code class="yaml">version: &quot;3.2&quot;

services:
  portainer: 
    container_name: portainer
    image: portainer/portainer
    ports:
      - &quot;8000:8000&quot;
      - &quot;9000:9000&quot;
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - portainer_data:/data

volumes:
  portainer_data: 
    external:
      true
</code></pre>
<h3 id="14-2-登录和使用Portainer"><a href="#14-2-登录和使用Portainer" class="headerlink" title="14.2 登录和使用Portainer"></a>14.2 登录和使用Portainer</h3><p>用浏览器访问：<code>http://localhost:9000</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/image-20201223231707738.png" alt="image-20201223231707738"></p>
<p> Stacks指的是你运行的docker-compose，一个项目就是一个Stacks</p>
<p><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/image-20210620005645817.png" alt="image-20210620005645817"></p>
<h2 id="15-Docker-问题"><a href="#15-Docker-问题" class="headerlink" title="15.Docker 问题"></a>15.Docker 问题</h2><h3 id="x509-certificate"><a href="#x509-certificate" class="headerlink" title="x509: certificate"></a>x509: certificate</h3><pre><code class="powershell">[root@localhost ~]# docker search 或者 docker pull 这些命令无法使用
Error response from daemon: Get https://index.docker.io/v1/search?q=mysql&amp;n=25: x509: certificate has expired or is not yet valid
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/image-20200602183429286.png" alt="image-20200602183429286"></p>
<ul>
<li>注意:<strong>这个错误的原因在于是系统的时间和docker hub时间不一致,需要做系统时间与网络时间同步</strong></li>
</ul>
<pre><code class="markdown"># 1.安装时间同步
    sudo yum -y install ntp ntpdate
# 2.同步时间
    sudo ntpdate cn.pool.ntp.org
# 3.查看本机时间
    date
# 4.从新测试
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/md/docker/image-20200602183718623.png" alt="image-20200602183718623"></p>

        </div>
        <!-- .entry-content -->
        <div class="single-reward">
          <div class="reward-open">赏
            <div class="reward-main">
              <ul class="reward-row">
                <li class="alipay-code"><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/img/custom/wechat.jpg"></li>
                <li class="wechat-code"><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/img/custom/qq.jpg"></li>
              </ul>
            </div>
          </div>
        </div>
        <div style="text-align:center; width: 100%" class="social-share share-mobile" data-disabled="diandian, tencent"></div>
        <footer class="post-footer">
          <div class="post-lincenses"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="nofollow"><i class="fa fa-creative-commons" aria-hidden="true"></i> 知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a></div>
          <div class="post-tags">
          </div>
          <div class="post-share">
            <div class="social-share sharehidden share-component"></div>
            <i class="iconfont show-share icon-forward"></i>
          </div>
        </footer><!-- .entry-footer -->
      </article>
      <!-- #post-## -->
      <div class="toc" style="background: none;"></div>
      <section class="post-squares nextprev">
        
        
      </section>
      
<div id="vcomments"></div>
<script>
  window.onload = function(){
      var valine = new Valine();
      valine.init({
        el: '#vcomments',
        appId: "XimjXrztzD4IysJIh75YxAAX-gzGzoHsz",
        appKey: "khl1hWHMQg21hOiDrW4UCqt1",
        path: window.location.pathname,
        placeholder: "记得填写扣扣邮箱同步头像哦~"
      })
  }
</script>

      <section class="author-profile">
        <div class="info" itemprop="author" itemscope="" itemtype="https://schema.org/Person">
          <a href="lkarrie.com" class="profile gravatar"><img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/img/custom/avatar2.jpg" itemprop="image" alt="lkarrie" height="70" width="70"></a>
          <div class="meta">
            <span class="title">Author</span>
            <h3 itemprop="name">
            <a href="lkarrie.com" itemprop="url" rel="author">lkarrie</a>
            </h3>
          </div>
        </div>
        <hr>
        <p><i class="iconfont icon-write"></i>noob</p>
      </section>
    </main><!-- #main -->
  </div><!-- #primary -->
</div>



    </div>    
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            // PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
    <footer id="colophon" class="site-footer" role="contentinfo">
  <div class="site-info" theme-info="Sakura v3.1.9">
    <div class="footertext">
      <div class="img-preload">
        <img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/img/other/wordpress-rotating-ball-o.svg">
        <img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/img/other/disqus-preloader.svg">
      </div>
      <p
        class="foo-logo"
        style="
          background-image: url('https://cdn.jsdelivr.net/gh/LKarrie/CDN/img/custom/sakura.svg');
        "
      ></p>
      <p style="font-family: 'Ubuntu', sans-serif">
        <span style="color: #666666"
          >Crafted with
          <i class="fa fa-heart animated" style="color: #e74c3c"></i> by
          <a
            rel="me"
            href="https://lkarrie.com"
            target="_blank"
            style="color: #000000; text-decoration: none"
            >LKarrie</a
          ></span
        >
      </p>
      <p>
        © 2020 樱花庄的咕咕
        <!-- <a href="http://www.beian.miit.gov.cn" target="_blank"
          >备案中</a
        > -->
      </p>
    </div>
    <div class="footer-device">
      <!-- <a href="https://www.aliyun.com/" target="_blank" alt="ALiYun" rel="nofollow">
        <img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/img/other/ailiyun2.png" alt="aliyun" style="height: 1.9em; max-height: 1.9em;padding-bottom: 0.3em;">
      </a>&nbsp;&nbsp;&nbsp;
      <a href="https://github.com/" target="_blank" alt="Github" rel="nofollow">
        <img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/img/other/Github.png" alt="github" style="height: 2.2em; max-height: 2.5em;padding-bottom: 0px;">
      </a>&nbsp;&nbsp;
      <a href="https://2heng.xin" target="_blank" alt="Mashiro" rel="nofollow">
        <img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/img/other/mashiro-logo.png" alt="Mashiro" style="height: 2.5em; max-height: 2em;padding-bottom: 0px; margin-bottom:0.2em">
      </a> -->

      
      <a href="https://www.aliyun.com/" target="_blank" alt="ALiYun" rel="nofollow"
        ><img
          src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/img/other/aliyun-logo2.png"
          alt="ALiYun"
          style="height: 1.5em" /></a
      >&nbsp;&nbsp;&nbsp;<a
        href="https://github.com/"
        target="_blank"
        alt="Github"
        rel="nofollow"
        ><img
          src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/img/other/github-logo.png"
          alt="Github"
          style="height: 1.5em" /></a
      >&nbsp;&nbsp;&nbsp;<a
        href="https://2heng.xin"
        target="_blank"
        alt="Mashiro"
        rel="nofollow"
        ><img
          src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/img/other/mashiro-logo.png"
          alt="Mashiro"
          style="height: 1.5em" /></a
      >

    </div>
  </div>
</footer>


<!-- <script src="/js/tocbot.js"></script> -->
<script type="text/javascript" src="/js/lib.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script type="text/javascript" src="/js/InsightSearch.js"></script>
<script type="text/javascript" src="/js/jquery.fancybox.min.js"></script>
<script type="text/javascript" src="/js/zoom.min.js"></script>
<script type="text/javascript" src="/js/sakura-app.js"></script>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<!-- <script src='//unpkg.com/valine@1.3.4/dist/Valine.min.js'></script> -->
<script type="text/javascript" src="/js/Valine.min.js"></script>
<script src="/js/botui.js"></script>
<!-- 不蒜子 网页计数器 -->
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
<script type="text/javascript">
/* <![CDATA[ */
if (/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  var Poi = {"pjax":"1","movies":{"url": "https://cdn.jsdelivr.net/gh/LKarrie/CDN@0.0.0/moive/","name":"The Pet Girl of Sakurasou.mp4","live":"close"},"windowheight":"fixed","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
} else {
  var Poi = {"pjax":"1","movies":{"url": "https://cdn.jsdelivr.net/gh/LKarrie/CDN@0.0.0/moive/","name":"The Pet Girl of Sakurasou.mp4","live":"open"},"windowheight":"auto","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
}
/* ]]> */

</script>
<script>
$(document).ready(function() {
  if ($(".toc").length > 0 && document.body.clientWidth > 1200) {
    if ($(".pattern-center").length > 0) { //有图的情况
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -400,
          scrollSmoothOffset: -85
      });
    } else {
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -85,
          scrollSmoothOffset: -85
      });
    }
    var offsetTop = $('.toc').offset().top - 95;
    window.onscroll = function() {
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
      if (scrollTop >= offsetTop) {
        $('.toc').addClass('toc-fixed');
      } else {
        $('.toc').removeClass('toc-fixed');
      }
    }
  }
});
</script>

    <div class="openNav no-select" style="height: 50px;">
      <div class="iconflat no-select" style="width: 50px; height: 50px;">
        <div class="icon"></div>
      </div>
      <div class="site-branding search-form-submit">
        <i class="iconfont js-toggle-search iconsearch icon-search"></i>
      </div>
    </div>
  </section>
  <div class="skin-menu no-select" id="mainskin" style="position: fixed">
 <div class="theme-controls row-container">
  <ul class="menu-list">
   <li id="white-bg"> <i class="fa fa-television" aria-hidden="true"></i></li>
   <li id="sakura-bg"> <i class="iconfont icon-sakura"></i></li>
   <li id="gribs-bg"> <i class="fa fa-slack" aria-hidden="true"></i></li>
   <li id="KAdots-bg"> <i class="iconfont icon-dots"></i></li>
   <li id="totem-bg"> <i class="fa fa-optin-monster" aria-hidden="true"></i></li>
   <li id="pixiv-bg"> <i class="iconfont icon-pixiv"></i></li>
   <li id="bing-bg"> <i class="iconfont icon-bing"></i></li>
   <li id="dark-bg"> <i class="fa fa-moon-o" aria-hidden="true"></i></li>
  </ul>
 </div>
</div>
<canvas id="night-mode-cover"></canvas> 
  <div class="changeSkin-gear no-select">
  <div class="keys" id="setbtn"> 
   <span id="open-skinMenu"> 切换主题 | SCHEME TOOL  
     <i class="iconfont icon-gear inline-block rotating"></i> 
   </span>
  </div>
</div>
  <div id="mo-nav" class="">
  <div class="m-avatar">
    <img src="https://cdn.jsdelivr.net/gh/LKarrie/CDN/img/custom/avatar2.jpg">
  </div>
  <p style="text-align: center; color: #333; font-weight: 900; font-family: 'Ubuntu', sans-serif; letter-spacing: 1.5px">樱花庄的臭鸽子:D</p>
  <p style="text-align: center; word-spacing: 20px;">
    
  </p>
  <ul id="menu-new-1" class="menu">
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
            首页
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/archives">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
            归档
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/categories/技术/">
                  <i class="fa fa-code" aria-hidden="true"></i>
                  技术
                </a>
              </li>
            
              <li>
                <a href="/categories/随想/">
                  <i class="fa fa-commenting-o" aria-hidden="true"></i>
                  随想
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="javascript:;">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
            标签
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/tags/前端/">
                  <i class="fa fa-window-maximize" aria-hidden="true"></i>
                  前端
                </a>
              </li>
            
              <li>
                <a href="/tags/后端/">
                  <i class="fa fa-leaf" aria-hidden="true"></i>
                  后端
                </a>
              </li>
            
              <li>
                <a href="/tags/系统/">
                  <i class="fa fa fa-linux" aria-hidden="true"></i>
                  系统
                </a>
              </li>
            
              <li>
                <a href="/tags/容器/">
                  <i class="fa fa-cubes" aria-hidden="true"></i>
                  容器
                </a>
              </li>
            
              <li>
                <a href="/tags/测试/">
                  <i class="fa fa-bar-chart" aria-hidden="true"></i>
                  测试
                </a>
              </li>
            
              <li>
                <a href="/tags/K8S/">
                  <i class="fa fa-cloud" aria-hidden="true"></i>
                  K8S
                </a>
              </li>
            
              <li>
                <a href="/tags/DBA/">
                  <i class="fa fa-database" aria-hidden="true"></i>
                  DBA
                </a>
              </li>
            
              <li>
                <a href="/tags/其他/">
                  <i class="fa fa-meh-o" aria-hidden="true"></i>
                  其他
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/resource/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-archive faa-horizontal" aria-hidden="true"></i>
            资源
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/game/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-server faa-bounce" aria-hidden="true"></i>
            游戏
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/comment/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
            留言板
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="javascript:;">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-heart faa-wrench" aria-hidden="true"></i>
            关于
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/about/">
                  <i class="fa fa-user-o" aria-hidden="true"></i>
                  我?
                </a>
              </li>
            
              <li>
                <a href="/theme-sakura/">
                  <i class="fa iconfont icon-sakura" aria-hidden="true"></i>
                  主题
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/mikutap/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-music faa-shake" aria-hidden="true"></i>
            Miku
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/steamgames/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-steam-square faa-shake" aria-hidden="true"></i>
            蒸汽
          </span>
        </a>
        
      </li>
    
  </ul>
  <p style="text-align: center; font-size: 13px; color: #b9b9b9;">&copy 2020 樱花庄的咕咕</p>
</div>
<button onclick="topFunction()" class="mobile-cd-top" id="moblieGoTop" title="Go to top" style="display: none;"><i class="fa fa-chevron-up" aria-hidden="true"></i></button>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
<!-- require MetingJS -->
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
<style>
  .aplayer .aplayer-lrc {
    height: 35px;
  }
  .aplayer .aplayer-lrc p{
    font-size: 16px;
    font-weight: 700;
    line-height: 18px !important;
  }
  .aplayer .aplayer-lrc p.aplayer-lrc-current{
    color: #FF1493;
  }
  .aplayer.aplayer-narrow .aplayer-body{
    left: -66px !important;
  }
  .aplayer.aplayer-fixed .aplayer-lrc {
    display: none;
  }
  .aplayer .aplayer-lrc.aplayer-lrc-hide {
      display:none !important;
  }
  .aplayer.aplayer-fixed .lrc-show {
    display: block;
    background: rgba(255, 255, 255, 0.8);
  }
</style>
<meting-js

    id="5054334685"

    server="netease"

    type="playlist"

    fixed="true"

    autoplay="false"

    loop="all"

    order="random"

    preload="none"

    volume="0.7"

    mutex="true"

</meting-js>
<script>
  $(function(){
    $('body').on('click', '.aplayer', function(){
      if($('.aplayer-button').hasClass('aplayer-play')) {
        $('.aplayer-lrc').removeClass('lrc-show');
      } else {
        $('.aplayer-lrc').addClass('lrc-show');
      }
    })
  });
</script>
  <!-- <script src="https://cdn.jsdelivr.net/gh/wallleap/cdn/js/sakura.js"></script> -->
</body>
</html>